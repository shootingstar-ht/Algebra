{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/AlgebraCommunityVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\nimport './interfaces/IAlgebraFactory.sol';\r\nimport './libraries/SafeTransfer.sol';\r\n\r\n/// @title Algebra community fee vault\r\n/// @notice Community fee from pools is sent here, if it is enabled\r\ncontract AlgebraCommunityVault {\r\n  event TokensWithdrawal(address indexed token, address indexed to, uint256 amount);\r\n\r\n  /// @dev The role can be granted in AlgebraFactory\r\n  bytes32 public constant COMMUNITY_FEE_WITHDRAWER_ROLE = keccak256('COMMUNITY_FEE_WITHDRAWER');\r\n  address private immutable factory;\r\n\r\n  modifier onlyWithdrawer() {\r\n    require(IAlgebraFactory(factory).hasRoleOrOwner(COMMUNITY_FEE_WITHDRAWER_ROLE, msg.sender));\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    factory = msg.sender;\r\n  }\r\n\r\n  function withdraw(address token, address to, uint256 amount) external onlyWithdrawer {\r\n    _withdraw(token, to, amount);\r\n  }\r\n\r\n  struct WithdrawTokensParams {\r\n    address token;\r\n    address to;\r\n    uint256 amount;\r\n  }\r\n\r\n  function withdrawTokens(WithdrawTokensParams[] calldata params) external onlyWithdrawer {\r\n    uint256 paramsLength = params.length;\r\n    unchecked {\r\n      for (uint256 i; i < paramsLength; ++i) _withdraw(params[i].token, params[i].to, params[i].amount);\r\n    }\r\n  }\r\n\r\n  function _withdraw(address token, address to, uint256 amount) private {\r\n    SafeTransfer.safeTransfer(token, to, amount);\r\n    emit TokensWithdrawal(token, to, amount);\r\n  }\r\n}\r\n"
    },
    "contracts/AlgebraFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\nimport './interfaces/IAlgebraFactory.sol';\r\nimport './interfaces/IAlgebraPoolDeployer.sol';\r\nimport './interfaces/IDataStorageOperator.sol';\r\nimport './base/AlgebraFeeConfiguration.sol';\r\nimport './libraries/Constants.sol';\r\nimport './libraries/AdaptiveFee.sol';\r\nimport './DataStorageOperator.sol';\r\nimport './AlgebraCommunityVault.sol';\r\n\r\nimport '@openzeppelin/contracts/access/Ownable2Step.sol';\r\nimport '@openzeppelin/contracts/access/AccessControlEnumerable.sol';\r\n\r\n/// @title Algebra factory\r\n/// @notice Is used to deploy pools and its dataStorages\r\n/// @dev Version: Algebra V2.1\r\ncontract AlgebraFactory is IAlgebraFactory, Ownable2Step, AccessControlEnumerable {\r\n  /// @inheritdoc IAlgebraFactory\r\n  bytes32 public constant override POOLS_ADMINISTRATOR_ROLE = keccak256('POOLS_ADMINISTRATOR');\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  address public immutable override poolDeployer;\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  address public immutable override communityVault;\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  address public override farmingAddress;\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  uint8 public override defaultCommunityFee;\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  uint256 public override renounceOwnershipStartTimestamp;\r\n\r\n  /// @dev time delay before ownership renouncement can be finished\r\n  uint256 private constant RENOUNCE_OWNERSHIP_DELAY = 1 days;\r\n\r\n  /// @dev values of constants for sigmoids in fee calculation formula\r\n  AlgebraFeeConfiguration public defaultFeeConfiguration;\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  mapping(address => mapping(address => address)) public override poolByPair;\r\n\r\n  constructor(address _poolDeployer) {\r\n    require(_poolDeployer != address(0));\r\n    poolDeployer = _poolDeployer;\r\n    communityVault = address(new AlgebraCommunityVault());\r\n    defaultFeeConfiguration = AdaptiveFee.initialFeeConfiguration();\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function owner() public view override(IAlgebraFactory, Ownable) returns (address) {\r\n    return super.owner();\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function hasRoleOrOwner(bytes32 role, address account) public view override returns (bool) {\r\n    return (owner() == account || super.hasRole(role, account));\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function createPool(address tokenA, address tokenB) external override returns (address pool) {\r\n    require(tokenA != tokenB);\r\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n    require(token0 != address(0));\r\n    require(poolByPair[token0][token1] == address(0));\r\n\r\n    IDataStorageOperator dataStorage = new DataStorageOperator(_computeAddress(token0, token1));\r\n    dataStorage.changeFeeConfiguration(defaultFeeConfiguration);\r\n\r\n    pool = IAlgebraPoolDeployer(poolDeployer).deploy(address(dataStorage), token0, token1);\r\n\r\n    poolByPair[token0][token1] = pool; // to avoid future addresses comparison we are populating the mapping twice\r\n    poolByPair[token1][token0] = pool;\r\n    emit Pool(token0, token1, pool);\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function setFarmingAddress(address newFarmingAddress) external override onlyOwner {\r\n    require(farmingAddress != newFarmingAddress);\r\n    farmingAddress = newFarmingAddress;\r\n    emit FarmingAddress(newFarmingAddress);\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function setDefaultCommunityFee(uint8 newDefaultCommunityFee) external override onlyOwner {\r\n    require(newDefaultCommunityFee <= Constants.MAX_COMMUNITY_FEE);\r\n    require(defaultCommunityFee != newDefaultCommunityFee);\r\n    defaultCommunityFee = newDefaultCommunityFee;\r\n    emit DefaultCommunityFee(newDefaultCommunityFee);\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function setDefaultFeeConfiguration(AlgebraFeeConfiguration calldata newConfig) external override onlyOwner {\r\n    AdaptiveFee.validateFeeConfiguration(newConfig);\r\n    defaultFeeConfiguration = newConfig;\r\n    emit DefaultFeeConfiguration(newConfig);\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function startRenounceOwnership() external override onlyOwner {\r\n    renounceOwnershipStartTimestamp = block.timestamp;\r\n    emit RenounceOwnershipStart(renounceOwnershipStartTimestamp, renounceOwnershipStartTimestamp + RENOUNCE_OWNERSHIP_DELAY);\r\n  }\r\n\r\n  /// @inheritdoc IAlgebraFactory\r\n  function stopRenounceOwnership() external override onlyOwner {\r\n    require(renounceOwnershipStartTimestamp != 0);\r\n    renounceOwnershipStartTimestamp = 0;\r\n    emit RenounceOwnershipStop(block.timestamp);\r\n  }\r\n\r\n  /// @dev Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore.\r\n  /// Can only be called by the current owner if RENOUNCE_OWNERSHIP_DELAY seconds\r\n  /// have passed since the call to the startRenounceOwnership() function.\r\n  function renounceOwnership() public override onlyOwner {\r\n    require(renounceOwnershipStartTimestamp != 0);\r\n    require(block.timestamp - renounceOwnershipStartTimestamp >= RENOUNCE_OWNERSHIP_DELAY);\r\n    renounceOwnershipStartTimestamp = 0;\r\n\r\n    super.renounceOwnership();\r\n    emit RenounceOwnershipFinish(block.timestamp);\r\n  }\r\n\r\n  /// @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n  /// Modified to fit with the role mechanism.\r\n  function _transferOwnership(address newOwner) internal override {\r\n    _revokeRole(DEFAULT_ADMIN_ROLE, owner());\r\n    super._transferOwnership(newOwner);\r\n    _grantRole(DEFAULT_ADMIN_ROLE, owner());\r\n  }\r\n\r\n  /// @dev keccak256 of AlgebraPool init bytecode. Used to compute pool address deterministically\r\n  bytes32 private constant POOL_INIT_CODE_HASH = 0x2e0544119360e02028470306a34fda8f0a32b9ffdf2eefe1a8ea323b09e8927a;\r\n\r\n  /// @notice Deterministically computes the pool address given the token0 and token1\r\n  /// @param token0 first token\r\n  /// @param token1 second token\r\n  /// @return pool The contract address of the Algebra pool\r\n  function _computeAddress(address token0, address token1) private view returns (address pool) {\r\n    pool = address(uint160(uint256(keccak256(abi.encodePacked(hex'ff', poolDeployer, keccak256(abi.encode(token0, token1)), POOL_INIT_CODE_HASH)))));\r\n  }\r\n}\r\n"
    },
    "contracts/base/AlgebraFeeConfiguration.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n// coefficients for sigmoids: α / (1 + e^( (β-x) / γ))\r\n// alpha1 + alpha2 + baseFee must be <= type(uint16).max\r\nstruct AlgebraFeeConfiguration {\r\n  uint16 alpha1; // max value of the first sigmoid\r\n  uint16 alpha2; // max value of the second sigmoid\r\n  uint32 beta1; // shift along the x-axis for the first sigmoid\r\n  uint32 beta2; // shift along the x-axis for the second sigmoid\r\n  uint16 gamma1; // horizontal stretch factor for the first sigmoid\r\n  uint16 gamma2; // horizontal stretch factor for the second sigmoid\r\n  uint16 baseFee; // minimum possible fee\r\n}\r\n"
    },
    "contracts/base/common/Timestamp.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\nabstract contract Timestamp {\r\n  /// @dev This function is created for testing by overriding it.\r\n  /// @return A timestamp converted to uint32\r\n  function _blockTimestamp() internal view virtual returns (uint32) {\r\n    return uint32(block.timestamp); // truncation is desired\r\n  }\r\n}\r\n"
    },
    "contracts/DataStorageOperator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\nimport './base/common/Timestamp.sol';\r\nimport './interfaces/IAlgebraFactory.sol';\r\nimport './interfaces/IDataStorageOperator.sol';\r\nimport './interfaces/pool/IAlgebraPoolState.sol';\r\n\r\nimport './libraries/DataStorage.sol';\r\nimport './libraries/AdaptiveFee.sol';\r\n\r\n/// @title Algebra timepoints data operator\r\n/// @notice This contract stores timepoints and calculates adaptive fee and statistical averages\r\ncontract DataStorageOperator is IDataStorageOperator, Timestamp {\r\n  uint256 internal constant UINT16_MODULO = 65536;\r\n\r\n  using DataStorage for DataStorage.Timepoint[UINT16_MODULO];\r\n\r\n  DataStorage.Timepoint[UINT16_MODULO] public override timepoints;\r\n  AlgebraFeeConfiguration public feeConfig;\r\n\r\n  /// @dev The role can be granted in AlgebraFactory\r\n  bytes32 public constant FEE_CONFIG_MANAGER = keccak256('FEE_CONFIG_MANAGER');\r\n\r\n  address private immutable pool;\r\n  address private immutable factory;\r\n\r\n  modifier onlyPool() {\r\n    require(msg.sender == pool, 'only pool can call this');\r\n    _;\r\n  }\r\n\r\n  constructor(address _pool) {\r\n    (factory, pool) = (msg.sender, _pool);\r\n  }\r\n\r\n  /// @inheritdoc IDataStorageOperator\r\n  function initialize(uint32 time, int24 tick) external override onlyPool {\r\n    return timepoints.initialize(time, tick);\r\n  }\r\n\r\n  /// @inheritdoc IDataStorageOperator\r\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata _config) external override {\r\n    require(msg.sender == factory || IAlgebraFactory(factory).hasRoleOrOwner(FEE_CONFIG_MANAGER, msg.sender));\r\n    AdaptiveFee.validateFeeConfiguration(_config);\r\n\r\n    feeConfig = _config;\r\n    emit FeeConfiguration(_config);\r\n  }\r\n\r\n  /// @inheritdoc IDataStorageOperator\r\n  function getSingleTimepoint(\r\n    uint32 time,\r\n    uint32 secondsAgo,\r\n    int24 tick,\r\n    uint16 lastIndex\r\n  ) external view override returns (int56 tickCumulative, uint112 volatilityCumulative) {\r\n    DataStorage.Timepoint memory result = timepoints.getSingleTimepoint(time, secondsAgo, tick, lastIndex, timepoints.getOldestIndex(lastIndex));\r\n    (tickCumulative, volatilityCumulative) = (result.tickCumulative, result.volatilityCumulative);\r\n  }\r\n\r\n  /// @inheritdoc IDataStorageOperator\r\n  function getTimepoints(\r\n    uint32[] memory secondsAgos\r\n  ) external view override returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives) {\r\n    (, int24 tick, , , uint16 index, , ) = IAlgebraPoolState(pool).globalState();\r\n    return timepoints.getTimepoints(_blockTimestamp(), secondsAgos, tick, index);\r\n  }\r\n\r\n  /// @inheritdoc IDataStorageOperator\r\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external override onlyPool returns (uint16 indexUpdated, uint16 newFee) {\r\n    uint16 oldestIndex;\r\n    (indexUpdated, oldestIndex) = timepoints.write(index, blockTimestamp, tick);\r\n\r\n    if (index != indexUpdated) {\r\n      AlgebraFeeConfiguration memory _feeConfig = feeConfig;\r\n      if (_feeConfig.alpha1 | _feeConfig.alpha2 == 0) {\r\n        newFee = _feeConfig.baseFee;\r\n      } else {\r\n        uint88 lastVolatilityCumulative = timepoints[indexUpdated].volatilityCumulative;\r\n        uint88 volatilityAverage = timepoints.getAverageVolatility(blockTimestamp, tick, indexUpdated, oldestIndex, lastVolatilityCumulative);\r\n        newFee = AdaptiveFee.getFee(volatilityAverage, _feeConfig);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IDataStorageOperator\r\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external {\r\n    require(!timepoints[startIndex].initialized); // if not initialized, then all subsequent ones too\r\n    require(amount > 0 && type(uint16).max - startIndex >= amount);\r\n\r\n    unchecked {\r\n      for (uint256 i = startIndex; i < startIndex + amount; ++i) {\r\n        timepoints[i].blockTimestamp = 1; // will be overwritten\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IAlgebraFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\npragma abicoder v2;\r\n\r\nimport '../base/AlgebraFeeConfiguration.sol';\r\n\r\n/// @title The interface for the Algebra Factory\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraFactory {\r\n  /// @notice Emitted when a process of ownership renounce is started\r\n  /// @param timestamp The timestamp of event\r\n  /// @param finishTimestamp The timestamp when ownership renounce will be possible to finish\r\n  event RenounceOwnershipStart(uint256 timestamp, uint256 finishTimestamp);\r\n\r\n  /// @notice Emitted when a process of ownership renounce cancelled\r\n  /// @param timestamp The timestamp of event\r\n  event RenounceOwnershipStop(uint256 timestamp);\r\n\r\n  /// @notice Emitted when a process of ownership renounce finished\r\n  /// @param timestamp The timestamp of ownership renouncement\r\n  event RenounceOwnershipFinish(uint256 timestamp);\r\n\r\n  /// @notice Emitted when a pool is created\r\n  /// @param token0 The first token of the pool by address sort order\r\n  /// @param token1 The second token of the pool by address sort order\r\n  /// @param pool The address of the created pool\r\n  event Pool(address indexed token0, address indexed token1, address pool);\r\n\r\n  /// @notice Emitted when the farming address is changed\r\n  /// @param newFarmingAddress The farming address after the address was changed\r\n  event FarmingAddress(address indexed newFarmingAddress);\r\n\r\n  /// @notice Emitted when the default fee configuration is changed\r\n  /// @param newConfig The structure with dynamic fee parameters\r\n  /// @dev See the AdaptiveFee library for more details\r\n  event DefaultFeeConfiguration(AlgebraFeeConfiguration newConfig);\r\n\r\n  /// @notice Emitted when the default community fee is changed\r\n  /// @param newDefaultCommunityFee The new default community fee value\r\n  event DefaultCommunityFee(uint8 newDefaultCommunityFee);\r\n\r\n  /// @notice role that can change communityFee and tickspacing in pools\r\n  function POOLS_ADMINISTRATOR_ROLE() external view returns (bytes32);\r\n\r\n  /// @dev Returns `true` if `account` has been granted `role` or `account` is owner.\r\n  function hasRoleOrOwner(bytes32 role, address account) external view returns (bool);\r\n\r\n  /// @notice Returns the current owner of the factory\r\n  /// @dev Can be changed by the current owner via transferOwnership(address newOwner)\r\n  /// @return The address of the factory owner\r\n  function owner() external view returns (address);\r\n\r\n  /// @notice Returns the current poolDeployerAddress\r\n  /// @return The address of the poolDeployer\r\n  function poolDeployer() external view returns (address);\r\n\r\n  /// @dev Is retrieved from the pools to restrict calling certain functions not by a tokenomics contract\r\n  /// @return The tokenomics contract address\r\n  function farmingAddress() external view returns (address);\r\n\r\n  /// @notice Returns the current communityVaultAddress\r\n  /// @return The address to which community fees are transferred\r\n  function communityVault() external view returns (address);\r\n\r\n  /// @notice Returns the default community fee\r\n  /// @return Fee which will be set at the creation of the pool\r\n  function defaultCommunityFee() external view returns (uint8);\r\n\r\n  /// @notice Returns the pool address for a given pair of tokens, or address 0 if it does not exist\r\n  /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n  /// @param tokenA The contract address of either token0 or token1\r\n  /// @param tokenB The contract address of the other token\r\n  /// @return pool The pool address\r\n  function poolByPair(address tokenA, address tokenB) external view returns (address pool);\r\n\r\n  /// @return timestamp The timestamp of the beginning of the renounceOwnership process\r\n  function renounceOwnershipStartTimestamp() external view returns (uint256 timestamp);\r\n\r\n  /// @notice Creates a pool for the given two tokens\r\n  /// @param tokenA One of the two tokens in the desired pool\r\n  /// @param tokenB The other of the two tokens in the desired pool\r\n  /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0.\r\n  /// The call will revert if the pool already exists or the token arguments are invalid.\r\n  /// @return pool The address of the newly created pool\r\n  function createPool(address tokenA, address tokenB) external returns (address pool);\r\n\r\n  /// @dev updates tokenomics address on the factory\r\n  /// @param newFarmingAddress The new tokenomics contract address\r\n  function setFarmingAddress(address newFarmingAddress) external;\r\n\r\n  /// @dev updates default community fee for new pools\r\n  /// @param newDefaultCommunityFee The new community fee, _must_ be <= MAX_COMMUNITY_FEE\r\n  function setDefaultCommunityFee(uint8 newDefaultCommunityFee) external;\r\n\r\n  /// @notice Changes initial fee configuration for new pools\r\n  /// @dev changes coefficients for sigmoids: α / (1 + e^( (β-x) / γ))\r\n  /// alpha1 + alpha2 + baseFee (max possible fee) must be <= type(uint16).max and gammas must be > 0\r\n  /// @param newConfig new default fee configuration. See the #AdaptiveFee.sol library for details\r\n  function setDefaultFeeConfiguration(AlgebraFeeConfiguration calldata newConfig) external;\r\n\r\n  /// @notice Starts process of renounceOwnership. After that, a certain period\r\n  /// of time must pass before the ownership renounce can be completed.\r\n  function startRenounceOwnership() external;\r\n\r\n  /// @notice Stops process of renounceOwnership and removes timer.\r\n  function stopRenounceOwnership() external;\r\n}\r\n"
    },
    "contracts/interfaces/IAlgebraPoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title An interface for a contract that is capable of deploying Algebra Pools\r\n/// @notice A contract that constructs a pool must implement this to pass arguments to the pool\r\n/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash\r\n/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain.\r\n/// Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolDeployer {\r\n  /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.\r\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\r\n  /// @return dataStorage The pools associated dataStorage\r\n  /// @return factory The factory address\r\n  /// @return communityVault The community vault address\r\n  /// @return token0 The first token of the pool by address sort order\r\n  /// @return token1 The second token of the pool by address sort order\r\n  function getDeployParameters() external view returns (address dataStorage, address factory, address communityVault, address token0, address token1);\r\n\r\n  /// @dev Deploys a pool with the given parameters by transiently setting the parameters in cache.\r\n  /// @param dataStorage The pools associated dataStorage\r\n  /// @param token0 The first token of the pool by address sort order\r\n  /// @param token1 The second token of the pool by address sort order\r\n  /// @return pool The deployed pool's address\r\n  function deploy(address dataStorage, address token0, address token1) external returns (address pool);\r\n}\r\n"
    },
    "contracts/interfaces/IAlgebraPoolErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.4 <0.9.0;\r\n\r\n/// @title Errors emitted by a pool\r\n/// @notice Contains custom errors emitted by the pool\r\ninterface IAlgebraPoolErrors {\r\n  // ####  pool errors  ####\r\n\r\n  /// @notice Emitted by the reentrancy guard\r\n  error locked();\r\n\r\n  /// @notice Emitted if arithmetic error occurred\r\n  error arithmeticError();\r\n\r\n  /// @notice Emitted if an attempt is made to initialize the pool twice\r\n  error alreadyInitialized();\r\n\r\n  /// @notice Emitted if 0 is passed as amountRequired to swap function\r\n  error zeroAmountRequired();\r\n\r\n  /// @notice Emitted if invalid amount is passed as amountRequired to swapSupportingFeeOnInputTokens function\r\n  error invalidAmountRequired();\r\n\r\n  /// @notice Emitted if the pool received fewer tokens than it should have\r\n  error insufficientInputAmount();\r\n  /// @notice Emitted if the pool received fewer tokens than it should have to mint calculated actual liquidity\r\n  error insufficientAmountReceivedAtMint();\r\n\r\n  /// @notice Emitted if there was an attempt to mint zero liquidity\r\n  error zeroLiquidityDesired();\r\n  /// @notice Emitted if actual amount of liquidity is zero (due to insufficient amount of tokens received)\r\n  error zeroLiquidityActual();\r\n\r\n  /// @notice Emitted if the pool received fewer tokens{0,1} after flash than it should have\r\n  error flashInsufficientPaid0();\r\n  error flashInsufficientPaid1();\r\n\r\n  /// @notice Emitted if limitSqrtPrice param is incorrect\r\n  error invalidLimitSqrtPrice();\r\n\r\n  /// @notice Tick must be divisible by tickspacing\r\n  error tickIsNotSpaced();\r\n\r\n  /// @notice Emitted if a method is called that is accessible only to the factory owner or dedicated role\r\n  error notAllowed();\r\n  /// @notice Emitted if a method is called that is accessible only to the farming\r\n  error onlyFarming();\r\n\r\n  error invalidNewTickSpacing();\r\n  error invalidNewCommunityFee();\r\n\r\n  // ####  LimitOrder errors  ####\r\n  /// @notice Emitted if tick is too low/high for limit order\r\n  error invalidTickForLimitOrder();\r\n  /// @notice Emitted if amount is too high for limit order\r\n  error invalidAmountForLimitOrder();\r\n\r\n  // ####  LiquidityMath errors  ####\r\n  /// @notice Emitted if liquidity underflows\r\n  error liquiditySub();\r\n  /// @notice Emitted if liquidity overflows\r\n  error liquidityAdd();\r\n\r\n  // ####  TickManagement errors  ####\r\n  error topTickLowerThanBottomTick();\r\n  error bottomTickLowerThanMIN();\r\n  error topTickAboveMAX();\r\n  error liquidityOverflow();\r\n  error tickIsNotInitialized();\r\n  error tickInvalidLinks();\r\n\r\n  // ####  SafeTransfer errors  ####\r\n  error transferFailed();\r\n\r\n  // ####  TickMath errors  ####\r\n  error tickOutOfRange();\r\n  error priceOutOfRange();\r\n}\r\n"
    },
    "contracts/interfaces/IDataStorageOperator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\npragma abicoder v2;\r\n\r\nimport '../base/AlgebraFeeConfiguration.sol';\r\n\r\n/// @title The interface for the DataStorageOperator\r\n/// @dev This contract stores timepoints and calculates adaptive fee and statistical averages\r\ninterface IDataStorageOperator {\r\n  /// @notice Emitted when the fee configuration is changed\r\n  /// @param feeConfig The structure with dynamic fee parameters\r\n  /// @dev See the AdaptiveFee library for more details\r\n  event FeeConfiguration(AlgebraFeeConfiguration feeConfig);\r\n\r\n  /// @notice Returns data belonging to a certain timepoint\r\n  /// @param index The index of timepoint in the array\r\n  /// @dev There is more convenient function to fetch a timepoint: getTimepoints(). Which requires not an index but seconds\r\n  /// @return initialized Whether the timepoint has been initialized and the values are safe to use\r\n  /// @return blockTimestamp The timestamp of the timepoint\r\n  /// @return tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\r\n  /// @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\r\n  /// @return tick The tick at blockTimestamp\r\n  /// @return averageTick Time-weighted average tick\r\n  /// @return windowStartIndex Index of closest timepoint >= WINDOW seconds ago\r\n  function timepoints(\r\n    uint256 index\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      bool initialized,\r\n      uint32 blockTimestamp,\r\n      int56 tickCumulative,\r\n      uint88 volatilityCumulative,\r\n      int24 tick,\r\n      int24 averageTick,\r\n      uint16 windowStartIndex\r\n    );\r\n\r\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\r\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\r\n  /// @param tick Initial tick\r\n  function initialize(uint32 time, int24 tick) external;\r\n\r\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\r\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\r\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\r\n  /// at exactly the timestamp between the two timepoints.\r\n  /// @param time The current block timestamp\r\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\r\n  /// @param tick The current tick\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\r\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\r\n  function getSingleTimepoint(\r\n    uint32 time,\r\n    uint32 secondsAgo,\r\n    int24 tick,\r\n    uint16 index\r\n  ) external view returns (int56 tickCumulative, uint112 volatilityCumulative);\r\n\r\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\r\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\r\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\r\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\r\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\r\n  function getTimepoints(uint32[] memory secondsAgos) external view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives);\r\n\r\n  /// @notice Writes a dataStorage timepoint to the array\r\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param blockTimestamp The timestamp of the new timepoint\r\n  /// @param tick The active tick at the time of the new timepoint\r\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\r\n  /// @return newFee The fee in hundredths of a bip, i.e. 1e-6\r\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external returns (uint16 indexUpdated, uint16 newFee);\r\n\r\n  /// @notice Changes fee configuration for the pool\r\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata feeConfig) external;\r\n\r\n  /// @notice Fills uninitialized timepoints with nonzero value\r\n  /// @dev Can be used to reduce the gas cost of future swaps\r\n  /// @param startIndex The start index, must be not initialized\r\n  /// @param amount of slots to fill, startIndex + amount must be <= type(uint16).max\r\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/pool/IAlgebraPoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Pool state that can change\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolState {\r\n  /// @notice The globalState structure in the pool stores many values but requires only one slot\r\n  /// and is exposed as a single method to save gas when accessed externally.\r\n  /// @return price The current price of the pool as a sqrt(dToken1/dToken0) Q64.96 value;\r\n  /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run;\r\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick boundary;\r\n  /// @return prevInitializedTick The previous initialized tick\r\n  /// @return fee The last pool fee value in hundredths of a bip, i.e. 1e-6\r\n  /// @return timepointIndex The index of the last written timepoint\r\n  /// @return communityFee The community fee percentage of the swap fee in thousandths (1e-3)\r\n  /// @return unlocked Whether the pool is currently locked to reentrancy\r\n  function globalState()\r\n    external\r\n    view\r\n    returns (uint160 price, int24 tick, int24 prevInitializedTick, uint16 fee, uint16 timepointIndex, uint8 communityFee, bool unlocked);\r\n\r\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\r\n  /// @dev This value can overflow the uint256\r\n  function totalFeeGrowth0Token() external view returns (uint256);\r\n\r\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\r\n  /// @dev This value can overflow the uint256\r\n  function totalFeeGrowth1Token() external view returns (uint256);\r\n\r\n  /// @notice The currently in range liquidity available to the pool\r\n  /// @dev This value has no relationship to the total liquidity across all ticks.\r\n  /// Returned value cannot exceed type(uint128).max\r\n  function liquidity() external view returns (uint128);\r\n\r\n  /// @notice The current tick spacing\r\n  /// @dev Ticks can only be used at multiples of this value\r\n  /// e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\r\n  /// This value is an int24 to avoid casting even though it is always positive.\r\n  /// @return The current tick spacing\r\n  function tickSpacing() external view returns (int24);\r\n\r\n  /// @notice The current tick spacing for limit orders\r\n  /// @dev Ticks can only be used for limit orders at multiples of this value\r\n  /// This value is an int24 to avoid casting even though it is always positive.\r\n  /// @return The current tick spacing for limit orders\r\n  function tickSpacingLimitOrders() external view returns (int24);\r\n\r\n  /// @notice The timestamp of the last sending of tokens to community vault\r\n  function communityFeeLastTimestamp() external view returns (uint32);\r\n\r\n  /// @notice The amounts of token0 and token1 that will be sent to the vault\r\n  /// @dev Will be sent COMMUNITY_FEE_TRANSFER_FREQUENCY after communityFeeLastTimestamp\r\n  function getCommunityFeePending() external view returns (uint128 communityFeePending0, uint128 communityFeePending1);\r\n\r\n  /// @notice The tracked token0 and token1 reserves of pool\r\n  /// @dev If at any time the real balance is larger, the excess will be transferred to liquidity providers as additional fee.\r\n  /// If the balance exceeds uint128, the excess will be sent to the communityVault.\r\n  function getReserves() external view returns (uint128 reserve0, uint128 reserve1);\r\n\r\n  /// @notice The accumulator of seconds per liquidity since the pool was first initialized\r\n  function secondsPerLiquidityCumulative() external view returns (uint160);\r\n\r\n  /// @notice Look up information about a specific tick in the pool\r\n  /// @param tick The tick to look up\r\n  /// @return liquidityTotal The total amount of position liquidity that uses the pool either as tick lower or tick upper\r\n  /// @return liquidityDelta How much liquidity changes when the pool price crosses the tick\r\n  /// @return outerFeeGrowth0Token The fee growth on the other side of the tick from the current tick in token0\r\n  /// @return outerFeeGrowth1Token The fee growth on the other side of the tick from the current tick in token1\r\n  /// @return prevTick The previous tick in tick list\r\n  /// @return nextTick The next tick in tick list\r\n  /// @return outerSecondsPerLiquidity The seconds spent per liquidity on the other side of the tick from the current tick\r\n  /// @return outerSecondsSpent The seconds spent on the other side of the tick from the current tick\r\n  /// @return hasLimitOrders Whether there are limit orders on this tick or not\r\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\r\n  /// a specific position.\r\n  function ticks(\r\n    int24 tick\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint128 liquidityTotal,\r\n      int128 liquidityDelta,\r\n      uint256 outerFeeGrowth0Token,\r\n      uint256 outerFeeGrowth1Token,\r\n      int24 prevTick,\r\n      int24 nextTick,\r\n      uint160 outerSecondsPerLiquidity,\r\n      uint32 outerSecondsSpent,\r\n      bool hasLimitOrders\r\n    );\r\n\r\n  /// @notice Returns the summary information about a limit orders at tick\r\n  /// @param tick The tick to look up\r\n  /// @return amountToSell The amount of tokens to sell. Has only relative meaning\r\n  /// @return soldAmount The amount of tokens already sold. Has only relative meaning\r\n  /// @return boughtAmount0Cumulative The accumulator of bought tokens0 per amountToSell. Has only relative meaning\r\n  /// @return boughtAmount1Cumulative The accumulator of bought tokens1 per amountToSell. Has only relative meaning\r\n  /// @return initialized Will be true if a limit order was created at least once on this tick\r\n  function limitOrders(\r\n    int24 tick\r\n  )\r\n    external\r\n    view\r\n    returns (uint128 amountToSell, uint128 soldAmount, uint256 boughtAmount0Cumulative, uint256 boughtAmount1Cumulative, bool initialized);\r\n\r\n  /// @notice Returns 256 packed tick initialized boolean values. See TickTree for more information\r\n  function tickTable(int16 wordPosition) external view returns (uint256);\r\n\r\n  /// @notice Returns the information about a position by the position's key\r\n  /// @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\r\n  /// @return liquidity The amount of liquidity in the position\r\n  /// @return innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke\r\n  /// @return innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke\r\n  /// @return fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke\r\n  /// @return fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\r\n  function positions(\r\n    bytes32 key\r\n  ) external view returns (uint256 liquidity, uint256 innerFeeGrowth0Token, uint256 innerFeeGrowth1Token, uint128 fees0, uint128 fees1);\r\n\r\n  /// @notice Returns the information about active incentive\r\n  /// @dev if there is no active incentive at the moment, incentiveAddress would be equal to address(0)\r\n  /// @return incentiveAddress The address associated with the current active incentive\r\n  function activeIncentive() external view returns (address incentiveAddress);\r\n}\r\n"
    },
    "contracts/libraries/AdaptiveFee.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\nimport '../base/AlgebraFeeConfiguration.sol';\r\nimport './Constants.sol';\r\n\r\n/// @title AdaptiveFee\r\n/// @notice Calculates fee based on combination of sigmoids\r\nlibrary AdaptiveFee {\r\n  /// @notice Returns default initial fee configuration\r\n  function initialFeeConfiguration() internal pure returns (AlgebraFeeConfiguration memory) {\r\n    return\r\n      AlgebraFeeConfiguration(\r\n        3000 - Constants.BASE_FEE, // alpha1, max value of the first sigmoid in hundredths of a bip, i.e. 1e-6\r\n        15000 - 3000, // alpha2, max value of the second sigmoid in hundredths of a bip, i.e. 1e-6\r\n        360, // beta1, shift along the x-axis (volatility) for the first sigmoid\r\n        60000, // beta2, shift along the x-axis (volatility) for the second sigmoid\r\n        59, // gamma1, horizontal stretch factor for the first sigmoid\r\n        8500, // gamma2, horizontal stretch factor for the second sigmoid\r\n        Constants.BASE_FEE // baseFee in hundredths of a bip, i.e. 1e-6\r\n      );\r\n  }\r\n\r\n  /// @notice Validates fee configuration.\r\n  /// @dev Maximum fee value capped by baseFee + alpha1 + alpha2 must be <= type(uint16).max\r\n  /// gammas must be > 0\r\n  function validateFeeConfiguration(AlgebraFeeConfiguration memory _config) internal pure {\r\n    require(uint256(_config.alpha1) + uint256(_config.alpha2) + uint256(_config.baseFee) <= type(uint16).max, 'Max fee exceeded');\r\n    require(_config.gamma1 != 0 && _config.gamma2 != 0, 'Gammas must be > 0');\r\n  }\r\n\r\n  /// @notice Calculates fee based on formula:\r\n  /// baseFee + sigmoidVolume(sigmoid1(volatility, volumePerLiquidity) + sigmoid2(volatility, volumePerLiquidity))\r\n  /// maximum value capped by baseFee + alpha1 + alpha2\r\n  function getFee(uint88 volatility, AlgebraFeeConfiguration memory config) internal pure returns (uint16 fee) {\r\n    unchecked {\r\n      volatility /= 15; // normalize for 15 sec interval\r\n      uint256 sumOfSigmoids = sigmoid(volatility, config.gamma1, config.alpha1, config.beta1) +\r\n        sigmoid(volatility, config.gamma2, config.alpha2, config.beta2);\r\n\r\n      if (sumOfSigmoids > type(uint16).max) sumOfSigmoids = type(uint16).max; // should be impossible, just in case\r\n\r\n      return uint16(config.baseFee + sumOfSigmoids); // safe since alpha1 + alpha2 + baseFee _must_ be <= type(uint16).max\r\n    }\r\n  }\r\n\r\n  /// @notice calculates α / (1 + e^( (β-x) / γ))\r\n  /// that is a sigmoid with a maximum value of α, x-shifted by β, and stretched by γ\r\n  /// @dev returns uint256 for fuzzy testing. Guaranteed that the result is not greater than alpha\r\n  function sigmoid(uint256 x, uint16 g, uint16 alpha, uint256 beta) internal pure returns (uint256 res) {\r\n    unchecked {\r\n      if (x > beta) {\r\n        x = x - beta;\r\n        if (x >= 6 * uint256(g)) return alpha; // so x < 19 bits\r\n        uint256 g4 = uint256(g) ** 4; // < 64 bits (4*16)\r\n        uint256 ex = expXg4(x, g, g4); // < 155 bits\r\n        res = (alpha * ex) / (g4 + ex); // in worst case: (16 + 155 bits) / 155 bits\r\n        // so res <= alpha\r\n      } else {\r\n        x = beta - x;\r\n        if (x >= 6 * uint256(g)) return 0; // so x < 19 bits\r\n        uint256 g4 = uint256(g) ** 4; // < 64 bits (4*16)\r\n        uint256 ex = g4 + expXg4(x, g, g4); // < 156 bits\r\n        res = (alpha * g4) / ex; // in worst case: (16 + 128 bits) / 156 bits\r\n        // g8 <= ex, so res <= alpha\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice calculates e^(x/g) * g^4 in a series, since (around zero):\r\n  /// e^x = 1 + x + x^2/2 + ... + x^n/n! + ...\r\n  /// e^(x/g) = 1 + x/g + x^2/(2*g^2) + ... + x^(n)/(g^n * n!) + ...\r\n  /// @dev has good accuracy only if x/g < 6\r\n  function expXg4(uint256 x, uint16 g, uint256 gHighestDegree) internal pure returns (uint256 res) {\r\n    uint256 closestValue; // nearest 'table' value of e^(x/g), multiplied by 10^20\r\n    assembly {\r\n      let xdg := div(x, g)\r\n      switch xdg\r\n      case 0 {\r\n        closestValue := 100000000000000000000 // 1\r\n      }\r\n      case 1 {\r\n        closestValue := 271828182845904523536 // ~= e\r\n      }\r\n      case 2 {\r\n        closestValue := 738905609893065022723 // ~= e^2\r\n      }\r\n      case 3 {\r\n        closestValue := 2008553692318766774092 // ~= e^3\r\n      }\r\n      case 4 {\r\n        closestValue := 5459815003314423907811 // ~= e^4\r\n      }\r\n      default {\r\n        closestValue := 14841315910257660342111 // ~= e^5\r\n      }\r\n\r\n      x := mod(x, g)\r\n    }\r\n\r\n    unchecked {\r\n      if (x >= g / 2) {\r\n        // (x - closestValue) >= 0.5, so closestValue := closestValue * e^0.5\r\n        x -= g / 2;\r\n        closestValue = (closestValue * 164872127070012814684) / 1e20;\r\n      }\r\n\r\n      // After calculating the closestValue x/g is <= 0.5, so that the series in the neighborhood of zero converges with sufficient speed\r\n      uint256 xLowestDegree = x;\r\n      res = gHighestDegree; // g**4, res < 64 bits\r\n\r\n      gHighestDegree /= g; // g**3\r\n      res += xLowestDegree * gHighestDegree; // g**4 + x*g**3, res < 68\r\n\r\n      gHighestDegree /= g; // g**2\r\n      xLowestDegree *= x; // x**2\r\n      // g**4 + x * g**3 + (x**2 * g**2) / 2, res < 71\r\n      res += (xLowestDegree * gHighestDegree) / 2;\r\n\r\n      gHighestDegree /= g; // g\r\n      xLowestDegree *= x; // x**3\r\n      // g^4 + x * g^3 + (x^2 * g^2)/2 + x^3(g*4 + x)/24, res < 73\r\n      res += (xLowestDegree * g * 4 + xLowestDegree * x) / 24;\r\n\r\n      // res = g^4 * (1 + x/g + x^2/(2*g^2) + x^3/(6*g^3) + x^4/(24*g^4)) * closestValue / 10^20, closestValue < 75 bits, res < 155\r\n      res = (res * closestValue) / (1e20);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\nlibrary Constants {\r\n  uint8 internal constant RESOLUTION = 96;\r\n  uint256 internal constant Q32 = 1 << 32;\r\n  uint256 internal constant Q48 = 1 << 48;\r\n  uint256 internal constant Q64 = 1 << 64;\r\n  uint256 internal constant Q96 = 1 << 96;\r\n  uint256 internal constant Q128 = 1 << 128;\r\n  uint256 internal constant Q144 = 1 << 144;\r\n  int256 internal constant Q160 = 1 << 160;\r\n\r\n  uint16 internal constant BASE_FEE = 0.0001e6; // init minimum fee value in hundredths of a bip (0.01%)\r\n  uint24 internal constant FEE_DENOMINATOR = 1e6;\r\n  int24 internal constant INIT_TICK_SPACING = 60;\r\n  int24 internal constant MAX_TICK_SPACING = 500;\r\n\r\n  // Defines the maximum and minimum ticks allowed for limit orders. Corresponds to the range of possible\r\n  // price values ​​in UniswapV2. Due to this limitation, sufficient accuracy is achieved even with the minimum allowable tick\r\n  int24 constant MAX_LIMIT_ORDER_TICK = 776363;\r\n\r\n  // the frequency with which the accumulated community fees are sent to the vault\r\n  uint32 internal constant COMMUNITY_FEE_TRANSFER_FREQUENCY = 8 hours;\r\n\r\n  // max(uint128) / ( (MAX_TICK - MIN_TICK) )\r\n  uint128 internal constant MAX_LIQUIDITY_PER_TICK = 40564824043007195767232224305152;\r\n\r\n  uint8 internal constant MAX_COMMUNITY_FEE = 0.25e3; // 25%\r\n  uint256 internal constant COMMUNITY_FEE_DENOMINATOR = 1e3;\r\n  // role that can change communityFee and tickspacing in pools\r\n  bytes32 internal constant POOLS_ADMINISTRATOR_ROLE = keccak256('POOLS_ADMINISTRATOR');\r\n}\r\n"
    },
    "contracts/libraries/DataStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\n/// @title DataStorage\r\n/// @notice Provides price, liquidity, volatility data useful for a wide variety of system designs\r\n/// @dev Instances of stored dataStorage data, \"timepoints\", are collected in the dataStorage array\r\n/// Timepoints are overwritten when the full length of the dataStorage array is populated.\r\n/// The most recent timepoint is available by passing 0 to getSingleTimepoint()\r\nlibrary DataStorage {\r\n  /// @notice `target` timestamp is older than oldest timepoint\r\n  error targetIsTooOld();\r\n\r\n  uint32 internal constant WINDOW = 1 days;\r\n  uint256 private constant UINT16_MODULO = 65536;\r\n\r\n  struct Timepoint {\r\n    bool initialized; // whether or not the timepoint is initialized\r\n    uint32 blockTimestamp; // the block timestamp of the timepoint\r\n    int56 tickCumulative; // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\r\n    uint88 volatilityCumulative; // the volatility accumulator; overflow after ~34800 years is desired :)\r\n    int24 tick; // tick at this blockTimestamp\r\n    int24 averageTick; // average tick at this blockTimestamp (for WINDOW seconds)\r\n    uint16 windowStartIndex; // index of closest timepoint >= WINDOW seconds ago, used to speed up searches\r\n  }\r\n\r\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\r\n  /// @param self The stored dataStorage array\r\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\r\n  /// @param tick Initial tick\r\n  function initialize(Timepoint[UINT16_MODULO] storage self, uint32 time, int24 tick) internal {\r\n    Timepoint storage _zero = self[0];\r\n    require(!_zero.initialized);\r\n    (_zero.initialized, _zero.blockTimestamp, _zero.tick, _zero.averageTick) = (true, time, tick, tick);\r\n  }\r\n\r\n  /// @notice Writes a dataStorage timepoint to the array\r\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\r\n  /// @param self The stored dataStorage array\r\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param blockTimestamp The timestamp of the new timepoint\r\n  /// @param tick The active tick at the time of the new timepoint\r\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\r\n  /// @return oldestIndex The index of the oldest timepoint\r\n  function write(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint16 lastIndex,\r\n    uint32 blockTimestamp,\r\n    int24 tick\r\n  ) internal returns (uint16 indexUpdated, uint16 oldestIndex) {\r\n    Timepoint memory last = self[lastIndex];\r\n    // early return if we've already written a timepoint this block\r\n    if (last.blockTimestamp == blockTimestamp) return (lastIndex, 0);\r\n\r\n    // get next index considering overflow\r\n    unchecked {\r\n      indexUpdated = lastIndex + 1;\r\n    }\r\n\r\n    // check if we have overflow in the past\r\n    if (self[indexUpdated].initialized) oldestIndex = indexUpdated;\r\n\r\n    (int24 avgTick, uint16 windowStartIndex) = _getAverageTickCasted(\r\n      self,\r\n      blockTimestamp,\r\n      tick,\r\n      lastIndex,\r\n      oldestIndex,\r\n      last.blockTimestamp,\r\n      last.tickCumulative\r\n    );\r\n    self[indexUpdated] = _createNewTimepoint(last, blockTimestamp, tick, avgTick, windowStartIndex);\r\n    if (oldestIndex == indexUpdated) oldestIndex++; // previous oldest index has been overwritten\r\n  }\r\n\r\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\r\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\r\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\r\n  /// at exactly the timestamp between the two timepoints.\r\n  /// @param self The stored dataStorage array\r\n  /// @param time The current block timestamp\r\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\r\n  /// @param tick The current tick\r\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param oldestIndex The index of the oldest timepoint\r\n  /// @return targetTimepoint desired timepoint or it's approximation\r\n  function getSingleTimepoint(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    uint32 secondsAgo,\r\n    int24 tick,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex\r\n  ) internal view returns (Timepoint memory targetTimepoint) {\r\n    unchecked {\r\n      uint32 target = time - secondsAgo;\r\n      (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, bool samePoint, ) = _getTimepointsAt(self, time, target, lastIndex, oldestIndex);\r\n\r\n      targetTimepoint = beforeOrAt;\r\n      if (target == targetTimepoint.blockTimestamp) return targetTimepoint; // we're at the left boundary\r\n      if (samePoint) {\r\n        // if target is newer than last timepoint\r\n        (int24 avgTick, uint16 windowStartIndex) = _getAverageTickCasted(\r\n          self,\r\n          time,\r\n          tick,\r\n          lastIndex,\r\n          oldestIndex,\r\n          targetTimepoint.blockTimestamp,\r\n          targetTimepoint.tickCumulative\r\n        );\r\n        return _createNewTimepoint(targetTimepoint, time - secondsAgo, tick, avgTick, windowStartIndex);\r\n      }\r\n\r\n      (uint32 timestampAfter, int56 tickCumulativeAfter) = (atOrAfter.blockTimestamp, atOrAfter.tickCumulative);\r\n      if (target == timestampAfter) return atOrAfter; // we're at the right boundary\r\n\r\n      // we're in the middle\r\n      (uint32 timepointTimeDelta, uint32 targetDelta) = (timestampAfter - targetTimepoint.blockTimestamp, target - targetTimepoint.blockTimestamp);\r\n\r\n      targetTimepoint.tickCumulative +=\r\n        ((tickCumulativeAfter - targetTimepoint.tickCumulative) / int56(uint56(timepointTimeDelta))) *\r\n        int56(uint56(targetDelta));\r\n      targetTimepoint.volatilityCumulative +=\r\n        ((atOrAfter.volatilityCumulative - targetTimepoint.volatilityCumulative) / timepointTimeDelta) *\r\n        targetDelta;\r\n    }\r\n  }\r\n\r\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\r\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\r\n  /// @param self The stored dataStorage array\r\n  /// @param time The current block.timestamp\r\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\r\n  /// @param tick The current tick\r\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\r\n  /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\r\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\r\n  function getTimepoints(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    uint32[] memory secondsAgos,\r\n    int24 tick,\r\n    uint16 lastIndex\r\n  ) internal view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives) {\r\n    uint256 secondsLength = secondsAgos.length;\r\n    tickCumulatives = new int56[](secondsLength);\r\n    volatilityCumulatives = new uint112[](secondsLength);\r\n\r\n    uint16 oldestIndex = getOldestIndex(self, lastIndex);\r\n    Timepoint memory current;\r\n    unchecked {\r\n      for (uint256 i; i < secondsLength; ++i) {\r\n        current = getSingleTimepoint(self, time, secondsAgos[i], tick, lastIndex, oldestIndex);\r\n        (tickCumulatives[i], volatilityCumulatives[i]) = (current.tickCumulative, current.volatilityCumulative);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Returns the index of the oldest timepoint\r\n  /// @param self The stored dataStorage array\r\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\r\n  /// @return oldestIndex The index of the oldest timepoint\r\n  function getOldestIndex(Timepoint[UINT16_MODULO] storage self, uint16 lastIndex) internal view returns (uint16 oldestIndex) {\r\n    unchecked {\r\n      uint16 nextIndex = lastIndex + 1; // considering overflow\r\n      if (self[nextIndex].initialized) oldestIndex = nextIndex; // check if we have overflow in the past\r\n    }\r\n  }\r\n\r\n  /// @notice Returns average volatility in the range from time-WINDOW to time\r\n  /// @param self The stored dataStorage array\r\n  /// @param time The current block.timestamp\r\n  /// @param tick The current tick\r\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param oldestIndex The index of the oldest timepoint\r\n  /// @return volatilityAverage The average volatility in the recent range\r\n  function getAverageVolatility(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    int24 tick,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex,\r\n    uint88 lastCumulativeVolatility\r\n  ) internal view returns (uint88 volatilityAverage) {\r\n    unchecked {\r\n      uint32 oldestTimestamp = self[oldestIndex].blockTimestamp;\r\n\r\n      if (_lteConsideringOverflow(oldestTimestamp, time - WINDOW, time)) {\r\n        if (self[lastIndex].blockTimestamp == time) {\r\n          // we can simplify the search, because when the timepoint was created, the search was already done\r\n          oldestIndex = self[lastIndex].windowStartIndex;\r\n          oldestTimestamp = self[oldestIndex].blockTimestamp;\r\n          if (lastIndex != oldestIndex) lastIndex = oldestIndex + 1;\r\n        }\r\n\r\n        uint88 cumulativeVolatilityAtStart = _getVolatilityCumulativeAt(self, time, WINDOW, tick, lastIndex, oldestIndex);\r\n        return ((lastCumulativeVolatility - cumulativeVolatilityAtStart) / WINDOW); // sample is big enough to ignore bias of variance\r\n      } else if (time != oldestTimestamp) {\r\n        // recorded timepoints are not enough, so we will extrapolate\r\n        uint88 _oldestVolatilityCumulative = self[oldestIndex].volatilityCumulative;\r\n        uint32 unbiasedDenominator = time - oldestTimestamp;\r\n        if (unbiasedDenominator > 1) unbiasedDenominator--; // Bessel's correction for \"small\" sample\r\n        return ((lastCumulativeVolatility - _oldestVolatilityCumulative) / unbiasedDenominator);\r\n      }\r\n    }\r\n  }\r\n\r\n  // ##### further functions are private to the library, but some are made internal for fuzzy testing #####\r\n\r\n  /// @notice Transforms a previous timepoint into a new timepoint, given the passage of time and the current tick and liquidity values\r\n  /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\r\n  /// @dev The function changes the structure given to the input, and does not create a new one\r\n  /// @param last The specified timepoint to be used in creation of new timepoint\r\n  /// @param blockTimestamp The timestamp of the new timepoint\r\n  /// @param tick The active tick at the time of the new timepoint\r\n  /// @param averageTick The average tick at the time of the new timepoint\r\n  /// @param windowStartIndex The index of closest timepoint >= WINDOW seconds ago\r\n  /// @return Timepoint The newly populated timepoint\r\n  function _createNewTimepoint(\r\n    Timepoint memory last,\r\n    uint32 blockTimestamp,\r\n    int24 tick,\r\n    int24 averageTick,\r\n    uint16 windowStartIndex\r\n  ) private pure returns (Timepoint memory) {\r\n    unchecked {\r\n      uint32 delta = blockTimestamp - last.blockTimestamp; // overflow is desired\r\n      // We don't create a new structure in memory to save gas. Therefore, the function changes the old structure\r\n      last.initialized = true;\r\n      last.blockTimestamp = blockTimestamp;\r\n      last.tickCumulative += int56(tick) * int56(uint56(delta));\r\n      last.volatilityCumulative += uint88(_volatilityOnRange(int256(uint256(delta)), last.tick, tick, last.averageTick, averageTick)); // always fits 88 bits\r\n      last.tick = tick;\r\n      last.averageTick = averageTick;\r\n      last.windowStartIndex = windowStartIndex;\r\n      return last;\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates volatility between two sequential timepoints with resampling to 1 sec frequency\r\n  /// @param dt Timedelta between timepoints, must be within uint32 range\r\n  /// @param tick0 The tick at the left timepoint, must be within int24 range\r\n  /// @param tick1 The tick at the right timepoint, must be within int24 range\r\n  /// @param avgTick0 The average tick at the left timepoint, must be within int24 range\r\n  /// @param avgTick1 The average tick at the right timepoint, must be within int24 range\r\n  /// @return volatility The volatility between two sequential timepoints\r\n  /// If the requirements for the parameters are met, it always fits 88 bits\r\n  function _volatilityOnRange(int256 dt, int256 tick0, int256 tick1, int256 avgTick0, int256 avgTick1) internal pure returns (uint256 volatility) {\r\n    // On the time interval from the previous timepoint to the current\r\n    // we can represent tick and average tick change as two straight lines:\r\n    // tick = k*t + b, where k and b are some constants\r\n    // avgTick = p*t + q, where p and q are some constants\r\n    // we want to get sum of (tick(t) - avgTick(t))^2 for every t in the interval (0; dt]\r\n    // so: (tick(t) - avgTick(t))^2 = ((k*t + b) - (p*t + q))^2 = (k-p)^2 * t^2 + 2(k-p)(b-q)t + (b-q)^2\r\n    // since everything except t is a constant, we need to use progressions for t and t^2:\r\n    // sum(t) for t from 1 to dt = dt*(dt + 1)/2 = sumOfSequence\r\n    // sum(t^2) for t from 1 to dt = dt*(dt+1)*(2dt + 1)/6 = sumOfSquares\r\n    // so result will be: (k-p)^2 * sumOfSquares + 2(k-p)(b-q)*sumOfSequence + dt*(b-q)^2\r\n    unchecked {\r\n      int256 K = (tick1 - tick0) - (avgTick1 - avgTick0); // (k - p)*dt\r\n      int256 B = (tick0 - avgTick0) * dt; // (b - q)*dt\r\n      int256 sumOfSequence = dt * (dt + 1); // sumOfSequence * 2\r\n      int256 sumOfSquares = sumOfSequence * (2 * dt + 1); // sumOfSquares * 6\r\n      volatility = uint256((K ** 2 * sumOfSquares + 6 * B * K * sumOfSequence + 6 * dt * B ** 2) / (6 * dt ** 2));\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates average tick for WINDOW seconds at the moment of `time`\r\n  /// @dev Guaranteed that the result is within the bounds of int24\r\n  /// @return avgTick int256 for fuzzy tests\r\n  /// @return windowStartIndex The index of closest timepoint <= WINDOW seconds ago\r\n  function _getAverageTickCasted(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    int24 tick,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex,\r\n    uint32 lastTimestamp,\r\n    int56 lastTickCumulative\r\n  ) private view returns (int24 avgTick, uint16 windowStartIndex) {\r\n    (int256 _avgTick, uint256 _windowStartIndex) = _getAverageTick(self, time, tick, lastIndex, oldestIndex, lastTimestamp, lastTickCumulative);\r\n    unchecked {\r\n      (avgTick, windowStartIndex) = (int24(_avgTick), uint16(_windowStartIndex)); // overflow in uint16(_windowStartIndex) is desired\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates average tick for WINDOW seconds at the moment of `time`\r\n  /// @dev Guaranteed that the result is within the bounds of int24, but result is not casted\r\n  /// @return avgTick int256 for fuzzy tests\r\n  /// @return windowStartIndex The index of closest timepoint <= WINDOW seconds ago\r\n  function _getAverageTick(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    int24 tick,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex,\r\n    uint32 lastTimestamp,\r\n    int56 lastTickCumulative\r\n  ) internal view returns (int256 avgTick, uint256 windowStartIndex) {\r\n    (uint32 oldestTimestamp, int56 oldestTickCumulative) = (self[oldestIndex].blockTimestamp, self[oldestIndex].tickCumulative);\r\n    unchecked {\r\n      if (!_lteConsideringOverflow(oldestTimestamp, time - WINDOW, time)) {\r\n        // if oldest is newer than WINDOW ago\r\n        return (\r\n          (lastTimestamp == oldestTimestamp) ? tick : (lastTickCumulative - oldestTickCumulative) / int56(uint56(lastTimestamp - oldestTimestamp)),\r\n          oldestIndex\r\n        );\r\n      }\r\n\r\n      if (_lteConsideringOverflow(lastTimestamp, time - WINDOW, time)) {\r\n        Timepoint storage _start = self[lastIndex - 1]; // considering underflow\r\n        (bool initialized, uint32 startTimestamp, int56 startTickCumulative) = (_start.initialized, _start.blockTimestamp, _start.tickCumulative);\r\n        avgTick = initialized ? (lastTickCumulative - startTickCumulative) / int56(uint56(lastTimestamp - startTimestamp)) : tick;\r\n        windowStartIndex = lastIndex;\r\n      } else {\r\n        if (time == lastTimestamp) {\r\n          oldestIndex = self[lastIndex].windowStartIndex;\r\n          lastIndex = oldestIndex + 1;\r\n        }\r\n        int56 tickCumulativeAtStart;\r\n        (tickCumulativeAtStart, windowStartIndex) = _getTickCumulativeAt(self, time, WINDOW, tick, lastIndex, oldestIndex);\r\n\r\n        //    current-WINDOW  last   current\r\n        // _________*____________*_______*_\r\n        //           ||||||||||||\r\n        avgTick = (lastTickCumulative - tickCumulativeAtStart) / int56(uint56(lastTimestamp - time + WINDOW));\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice comparator for 32-bit timestamps\r\n  /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to currentTime\r\n  /// @param a A comparison timestamp from which to determine the relative position of `currentTime`\r\n  /// @param b From which to determine the relative position of `currentTime`\r\n  /// @param currentTime A timestamp truncated to 32 bits\r\n  /// @return res Whether `a` is chronologically <= `b`\r\n  function _lteConsideringOverflow(uint32 a, uint32 b, uint32 currentTime) private pure returns (bool res) {\r\n    res = a > currentTime;\r\n    if (res == b > currentTime) res = a <= b; // if both are on the same side\r\n  }\r\n\r\n  /// @notice Calculates cumulative volatility at the moment of `time` - `secondsAgo`\r\n  /// @dev More optimal than via `getSingleTimepoint`\r\n  /// @return volatilityCumulative The cumulative volatility\r\n  function _getVolatilityCumulativeAt(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    uint32 secondsAgo,\r\n    int24 tick,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex\r\n  ) internal view returns (uint88 volatilityCumulative) {\r\n    unchecked {\r\n      uint32 target = time - secondsAgo;\r\n      (Timepoint memory beforeOrAt, Timepoint storage atOrAfter, bool samePoint, ) = _getTimepointsAt(self, time, target, lastIndex, oldestIndex);\r\n\r\n      if (target == beforeOrAt.blockTimestamp) return beforeOrAt.volatilityCumulative; // we're at the left boundary\r\n      if (samePoint) {\r\n        // since target != beforeOrAt.blockTimestamp, `samePoint` means that target is newer than last timepoint\r\n        (int24 avgTick, ) = _getAverageTickCasted(self, time, tick, lastIndex, oldestIndex, beforeOrAt.blockTimestamp, beforeOrAt.tickCumulative);\r\n        return (beforeOrAt.volatilityCumulative +\r\n          uint88(_volatilityOnRange(int256(uint256(target - beforeOrAt.blockTimestamp)), beforeOrAt.tick, tick, beforeOrAt.averageTick, avgTick)));\r\n      }\r\n\r\n      (uint32 timestampAfter, uint88 volatilityCumulativeAfter) = (atOrAfter.blockTimestamp, atOrAfter.volatilityCumulative);\r\n      if (target == timestampAfter) return volatilityCumulativeAfter; // we're at the right boundary\r\n\r\n      // we're in the middle\r\n      (uint32 timepointTimeDelta, uint32 targetDelta) = (timestampAfter - beforeOrAt.blockTimestamp, target - beforeOrAt.blockTimestamp);\r\n\r\n      return beforeOrAt.volatilityCumulative + ((volatilityCumulativeAfter - beforeOrAt.volatilityCumulative) / timepointTimeDelta) * targetDelta;\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates cumulative tick at the moment of `time` - `secondsAgo`\r\n  /// @dev More optimal than via `getSingleTimepoint`\r\n  /// @return tickCumulative The cumulative tick\r\n  /// @return indexBeforeOrAt The index of closest timepoint before ot at the moment of `time` - `secondsAgo`\r\n  function _getTickCumulativeAt(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    uint32 secondsAgo,\r\n    int24 tick,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex\r\n  ) private view returns (int56 tickCumulative, uint256 indexBeforeOrAt) {\r\n    unchecked {\r\n      uint32 target = time - secondsAgo;\r\n      (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, bool samePoint, uint256 _indexBeforeOrAt) = _getTimepointsAt(\r\n        self,\r\n        time,\r\n        target,\r\n        lastIndex,\r\n        oldestIndex\r\n      );\r\n\r\n      (uint32 timestampBefore, int56 tickCumulativeBefore) = (beforeOrAt.blockTimestamp, beforeOrAt.tickCumulative);\r\n      if (target == timestampBefore) return (tickCumulativeBefore, _indexBeforeOrAt); // we're at the left boundary\r\n      // since target != timestampBefore, `samePoint` means that target is newer than last timepoint\r\n      if (samePoint) return ((tickCumulativeBefore + int56(tick) * int56(uint56(target - timestampBefore))), _indexBeforeOrAt); // if target is newer than last timepoint\r\n\r\n      (uint32 timestampAfter, int56 tickCumulativeAfter) = (atOrAfter.blockTimestamp, atOrAfter.tickCumulative);\r\n      if (target == timestampAfter) return (tickCumulativeAfter, _indexBeforeOrAt); // we're at the right boundary\r\n\r\n      // we're in the middle\r\n      (uint32 timepointTimeDelta, uint32 targetDelta) = (timestampAfter - timestampBefore, target - timestampBefore);\r\n      return (\r\n        tickCumulativeBefore + ((tickCumulativeAfter - tickCumulativeBefore) / int56(uint56(timepointTimeDelta))) * int56(uint56(targetDelta)),\r\n        _indexBeforeOrAt\r\n      );\r\n    }\r\n  }\r\n\r\n  /// @notice Returns closest timepoint or timepoints to the moment of `target`\r\n  /// @return beforeOrAt The timepoint recorded before, or at, the target\r\n  /// @return atOrAfter The timepoint recorded at, or after, the target\r\n  /// @return samePoint Are `beforeOrAt` and `atOrAfter` the same or not\r\n  /// @return indexBeforeOrAt The index of closest timepoint before ot at the moment of `target`\r\n  function _getTimepointsAt(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    uint32 target,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex\r\n  ) private view returns (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, bool samePoint, uint256 indexBeforeOrAt) {\r\n    // if target is newer than last timepoint\r\n    if (target == time || _lteConsideringOverflow(self[lastIndex].blockTimestamp, target, time)) {\r\n      return (self[lastIndex], self[lastIndex], true, lastIndex);\r\n    }\r\n\r\n    uint32 oldestTimestamp = self[oldestIndex].blockTimestamp;\r\n    if (!_lteConsideringOverflow(oldestTimestamp, target, time)) revert targetIsTooOld();\r\n\r\n    if (oldestTimestamp == target) return (self[oldestIndex], self[oldestIndex], true, oldestIndex);\r\n\r\n    unchecked {\r\n      if (time - target <= WINDOW) {\r\n        // we can limit the scope of the search\r\n        uint16 windowStartIndex = self[lastIndex].windowStartIndex;\r\n        if (windowStartIndex != oldestIndex) {\r\n          uint32 windowStartTimestamp = self[windowStartIndex].blockTimestamp;\r\n          if (_lteConsideringOverflow(oldestTimestamp, windowStartTimestamp, time)) {\r\n            (oldestIndex, oldestTimestamp) = (windowStartIndex, windowStartTimestamp);\r\n            if (oldestTimestamp == target) return (self[oldestIndex], self[oldestIndex], true, oldestIndex);\r\n          }\r\n        }\r\n      }\r\n      // no need to search if we already know the answer\r\n      if (lastIndex == oldestIndex + 1) return (self[oldestIndex], self[lastIndex], false, oldestIndex);\r\n    }\r\n\r\n    (beforeOrAt, atOrAfter, indexBeforeOrAt) = _binarySearch(self, time, target, lastIndex, oldestIndex);\r\n    return (beforeOrAt, atOrAfter, false, indexBeforeOrAt);\r\n  }\r\n\r\n  /// @notice Fetches the timepoints beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\r\n  /// The result may be the same timepoint, or adjacent timepoints.\r\n  /// @dev The answer must be contained in the array, used when the target is located within the stored timepoint\r\n  /// boundaries: older than the most recent timepoint and younger, or the same age as, the oldest timepoint\r\n  /// @param self The stored dataStorage array\r\n  /// @param time The current block.timestamp\r\n  /// @param target The timestamp at which the reserved timepoint should be for\r\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param oldestIndex The index of the oldest timepoint in the timepoints array\r\n  /// @return beforeOrAt The timepoint recorded before, or at, the target\r\n  /// @return atOrAfter The timepoint recorded at, or after, the target\r\n  function _binarySearch(\r\n    Timepoint[UINT16_MODULO] storage self,\r\n    uint32 time,\r\n    uint32 target,\r\n    uint16 lastIndex,\r\n    uint16 oldestIndex\r\n  ) private view returns (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, uint256 indexBeforeOrAt) {\r\n    unchecked {\r\n      uint256 left = oldestIndex; // oldest timepoint\r\n      uint256 right = lastIndex < oldestIndex ? lastIndex + UINT16_MODULO : lastIndex; // newest timepoint considering one index overflow\r\n      indexBeforeOrAt = (left + right) >> 1; // \"middle\" point between the boundaries\r\n\r\n      do {\r\n        beforeOrAt = self[uint16(indexBeforeOrAt)]; // checking the \"middle\" point between the boundaries\r\n        (bool initializedBefore, uint32 timestampBefore) = (beforeOrAt.initialized, beforeOrAt.blockTimestamp);\r\n        if (initializedBefore) {\r\n          if (_lteConsideringOverflow(timestampBefore, target, time)) {\r\n            // is current point before or at `target`?\r\n            atOrAfter = self[uint16(indexBeforeOrAt + 1)]; // checking the next point after \"middle\"\r\n            (bool initializedAfter, uint32 timestampAfter) = (atOrAfter.initialized, atOrAfter.blockTimestamp);\r\n            if (initializedAfter) {\r\n              if (_lteConsideringOverflow(target, timestampAfter, time)) {\r\n                // is the \"next\" point after or at `target`?\r\n                return (beforeOrAt, atOrAfter, indexBeforeOrAt); // the only fully correct way to finish\r\n              }\r\n              left = indexBeforeOrAt + 1; // \"next\" point is before the `target`, so looking in the right half\r\n            } else {\r\n              // beforeOrAt is initialized and <= target, and next timepoint is uninitialized\r\n              // should be impossible if initial boundaries and `target` are correct\r\n              return (beforeOrAt, beforeOrAt, indexBeforeOrAt);\r\n            }\r\n          } else {\r\n            right = indexBeforeOrAt - 1; // current point is after the `target`, so looking in the left half\r\n          }\r\n        } else {\r\n          // we've landed on an uninitialized timepoint, keep searching higher\r\n          // should be impossible if initial boundaries and `target` are correct\r\n          left = indexBeforeOrAt + 1;\r\n        }\r\n        indexBeforeOrAt = (left + right) >> 1; // calculating the new \"middle\" point index after updating the bounds\r\n      } while (true);\r\n\r\n      atOrAfter = beforeOrAt; // code is unreachable, to suppress compiler warning\r\n      assert(false); // code is unreachable, used for fuzzy testing\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/libraries/SafeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4 <0.9.0;\r\n\r\nimport '../interfaces/IAlgebraPoolErrors.sol';\r\n\r\n/// @title SafeTransfer\r\n/// @notice Safe ERC20 transfer library that gracefully handles missing return values.\r\n/// @dev Credit to Solmate under MIT license: https://github.com/transmissions11/solmate/blob/ed67feda67b24fdeff8ad1032360f0ee6047ba0a/src/utils/SafeTransferLib.sol\r\n/// @dev Please note that this library does not check if the token has a code! That responsibility is delegated to the caller.\r\nlibrary SafeTransfer {\r\n  /// @notice Transfers tokens to a recipient\r\n  /// @dev Calls transfer on token contract, errors with transferFailed() if transfer fails\r\n  /// @param token The contract address of the token which will be transferred\r\n  /// @param to The recipient of the transfer\r\n  /// @param amount The amount of the token to transfer\r\n  function safeTransfer(address token, address to, uint256 amount) internal {\r\n    bool success;\r\n    assembly {\r\n      let freeMemoryPointer := mload(0x40) // we will need to restore 0x40 slot\r\n      mstore(0x00, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // \"transfer(address,uint256)\" selector\r\n      mstore(0x04, and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // append cleaned \"to\" address\r\n      mstore(0x24, amount)\r\n      // now we use 0x00 - 0x44 bytes (68), freeMemoryPointer is dirty\r\n      success := call(gas(), token, 0, 0, 0x44, 0, 0x20)\r\n      success := and(\r\n        // set success to true if call isn't reverted and returned exactly 1 (can't just be non-zero data) or nothing\r\n        or(and(eq(mload(0), 1), eq(returndatasize(), 32)), iszero(returndatasize())),\r\n        success\r\n      )\r\n      mstore(0x40, freeMemoryPointer) // restore the freeMemoryPointer\r\n    }\r\n\r\n    if (!success) revert IAlgebraPoolErrors.transferFailed();\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}