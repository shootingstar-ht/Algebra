{
  "language": "Solidity",
  "sources": {
    "contracts/CircleStable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport './ERC20Permit.sol';\r\n\r\ncontract CircleStable is ERC20Permit {\r\n    constructor() ERC20Permit('Circle Stable', 'USDC', 6, 1e18) {}\r\n}\r\n"
    },
    "contracts/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\ncontract ERC20Permit {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _supply) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n\r\n        _mint(msg.sender, _supply);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, 'PERMIT_DEADLINE_EXPIRED');\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        '\\x19\\x01',\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNER');\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                    keccak256(bytes(name)),\r\n                    keccak256('1'),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "contracts/interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\r\npragma solidity ^0.8.17;\r\n\r\n/**\r\n * @dev Interface of the ERC2612 standard as defined in the EIP.\r\n *\r\n * Adds the {permit} method, which can be used to change one's\r\n * {IERC20-allowance} without having to send a transaction, by signing a\r\n * message. This allows users to spend tokens without having to hold Ether.\r\n *\r\n * See https://eips.ethereum.org/EIPS/eip-2612.\r\n */\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be `address(0)`.\r\n     * - `spender` cannot be `address(0)`.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use `owner`'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by EIP712.\r\n     */\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
    },
    "contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC3156FlashBorrower {\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n"
    },
    "contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport './IERC3156FlashBorrower.sol';\r\n\r\ninterface IERC3156FlashLender {\r\n    /**\r\n     * @dev The amount of currency available to be lended.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(address token) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(address token, uint256 amount) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Initiate a flash loan.\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IERC3156FlashBorrower receiver,\r\n        address token,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n// Adapted by Ethereum Community 2021\r\npragma solidity 0.8.17;\r\n\r\nimport './IERC20.sol';\r\nimport './IERC2612.sol';\r\nimport './IERC3156FlashLender.sol';\r\n\r\n/// @dev Wrapped Ether v10 (WETH10) is an Ether (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain a WETH10 balance which can then be operated as an ERC-20 token. You can\r\n/// `withdraw` ETH from WETH10, which will then burn WETH10 token in your wallet. The amount of WETH10 token in any wallet is always identical to the\r\n/// balance of ETH deposited minus the ETH withdrawn with that specific wallet.\r\ninterface IWETH10 is IERC20, IERC2612, IERC3156FlashLender {\r\n    /// @dev Returns current amount of flash-minted WETH10 token.\r\n    function flashMinted() external view returns (uint256);\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\r\n    function deposit() external payable;\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to `to` account.\r\n    function depositTo(address to) external payable;\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to the same.\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdraw(uint256 value) external;\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to account (`to`).\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdrawTo(address payable to, uint256 value) external;\r\n\r\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ETH to account (`to`).\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from account (`from`).\r\n    /// Requirements:\r\n    ///   - `from` account must have at least `value` balance of WETH10 token.\r\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\r\n    function withdrawFrom(address from, address payable to, uint256 value) external;\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function depositToAndCall(address to, bytes calldata data) external payable returns (bool);\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Approval} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {approveAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\r\n\r\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`),\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` WETH10 token.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function transferAndCall(address to, uint value, bytes calldata data) external returns (bool);\r\n}\r\n"
    },
    "contracts/test/TestFlashMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.17;\r\n\r\nimport '../interfaces/IWETH10.sol';\r\nimport '../interfaces/IERC3156FlashBorrower.sol';\r\n\r\ncontract TestFlashLender is IERC3156FlashBorrower {\r\n    enum Action {\r\n        NORMAL,\r\n        STEAL,\r\n        WITHDRAW,\r\n        REENTER\r\n    }\r\n\r\n    uint256 public flashBalance;\r\n    address public flashToken;\r\n    uint256 public flashValue;\r\n    address public flashSender;\r\n\r\n    receive() external payable {}\r\n\r\n    function onFlashLoan(\r\n        address sender,\r\n        address token,\r\n        uint256 value,\r\n        uint256,\r\n        bytes calldata data\r\n    ) external override returns (bytes32) {\r\n        address lender = msg.sender;\r\n        Action action = abi.decode(data, (Action)); // Use this to unpack arbitrary data\r\n        flashSender = sender;\r\n        flashToken = token;\r\n        flashValue = value;\r\n        if (action == Action.NORMAL) {\r\n            flashBalance = IWETH10(lender).balanceOf(address(this));\r\n        } else if (action == Action.WITHDRAW) {\r\n            IWETH10(lender).withdraw(value);\r\n            flashBalance = address(this).balance;\r\n            IWETH10(lender).deposit{value: value}();\r\n        } else if (action == Action.STEAL) {\r\n            // Do nothing\r\n        } else if (action == Action.REENTER) {\r\n            bytes memory newData = abi.encode(Action.NORMAL);\r\n            IWETH10(lender).approve(lender, IWETH10(lender).allowance(address(this), lender) + value * 2);\r\n            IWETH10(lender).flashLoan(this, address(lender), value * 2, newData);\r\n        }\r\n        return keccak256('ERC3156FlashBorrower.onFlashLoan');\r\n    }\r\n\r\n    function flashLoan(address lender, uint256 value) public {\r\n        // Use this to pack arbitrary data to `onFlashLoan`\r\n        bytes memory data = abi.encode(Action.NORMAL);\r\n        IWETH10(lender).approve(lender, value);\r\n        IWETH10(lender).flashLoan(this, address(lender), value, data);\r\n    }\r\n\r\n    function flashLoanAndWithdraw(address lender, uint256 value) public {\r\n        // Use this to pack arbitrary data to `onFlashLoan`\r\n        bytes memory data = abi.encode(Action.WITHDRAW);\r\n        IWETH10(lender).approve(lender, value);\r\n        IWETH10(lender).flashLoan(this, address(lender), value, data);\r\n    }\r\n\r\n    function flashLoanAndSteal(address lender, uint256 value) public {\r\n        // Use this to pack arbitrary data to `onFlashLoan`\r\n        bytes memory data = abi.encode(Action.STEAL);\r\n        IWETH10(lender).flashLoan(this, address(lender), value, data);\r\n    }\r\n\r\n    function flashLoanAndReenter(address lender, uint256 value) public {\r\n        // Use this to pack arbitrary data to `onFlashLoan`\r\n        bytes memory data = abi.encode(Action.REENTER);\r\n        IWETH10(lender).approve(lender, value);\r\n        IWETH10(lender).flashLoan(this, address(lender), value, data);\r\n    }\r\n}\r\n"
    },
    "contracts/test/TestTransferReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Copyright (C) 2015, 2016, 2017 Dapphub / adapted by [] 2020\r\npragma solidity 0.8.17;\r\n\r\ncontract TestTransferReceiver {\r\n    address public token;\r\n\r\n    event TransferReceived(address token, address sender, uint256 value, bytes data);\r\n    event ApprovalReceived(address token, address spender, uint256 value, bytes data);\r\n\r\n    function onTokenTransfer(address sender, uint value, bytes calldata data) external returns (bool) {\r\n        emit TransferReceived(msg.sender, sender, value, data);\r\n        return true;\r\n    }\r\n\r\n    function onTokenApproval(address spender, uint value, bytes calldata data) external returns (bool) {\r\n        emit ApprovalReceived(msg.sender, spender, value, data);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/test/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n//contract not audited do not use\r\ncontract WETH9 {\r\n    string public name = 'Wrapped Ether';\r\n    string public symbol = 'WETH';\r\n    uint8 public decimals = 18;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint256 wad);\r\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\r\n    event Deposit(address indexed dst, uint256 wad);\r\n    event Withdrawal(address indexed src, uint256 wad);\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    receive() external payable {\r\n        deposit();\r\n    }\r\n\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint256 wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        payable(msg.sender).transfer(wad);\r\n        emit Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function approve(address guy, uint256 wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/WethConverter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n// Adapted by Ethereum Community 2021\r\npragma solidity 0.8.17;\r\n\r\ninterface WETH9Like {\r\n    function withdraw(uint) external;\r\n\r\n    function deposit() external payable;\r\n\r\n    function transfer(address, uint) external returns (bool);\r\n\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface WETH10Like {\r\n    function depositTo(address) external payable;\r\n\r\n    function withdrawFrom(address, address, uint256) external;\r\n}\r\n\r\ncontract WethConverter {\r\n    WETH9Like private constant weth9 = WETH9Like(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // ETH wrapper contract v9\r\n    WETH10Like private constant weth10 = WETH10Like(0xf4BB2e28688e89fCcE3c0580D37d36A7672E8A9F); // ETH wrapper contract v10\r\n\r\n    receive() external payable {}\r\n\r\n    function weth9ToWeth10(address account, uint256 value) external payable {\r\n        weth9.transferFrom(account, address(this), value);\r\n        weth9.withdraw(value);\r\n        weth10.depositTo{value: value + msg.value}(account);\r\n    }\r\n\r\n    function weth10ToWeth9(address account, uint256 value) external payable {\r\n        weth10.withdrawFrom(account, address(this), value);\r\n        uint256 combined = value + msg.value;\r\n        weth9.deposit{value: combined}();\r\n        weth9.transfer(account, combined);\r\n    }\r\n}\r\n"
    },
    "contracts/WrappedEther.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n// Adapted by Ethereum Community 2021\r\npragma solidity 0.8.17;\r\n\r\nimport './interfaces/IWETH10.sol';\r\nimport './interfaces/IERC3156FlashBorrower.sol';\r\n\r\ninterface ITransferReceiver {\r\n    function onTokenTransfer(address, uint, bytes calldata) external returns (bool);\r\n}\r\n\r\ninterface IApprovalReceiver {\r\n    function onTokenApproval(address, uint, bytes calldata) external returns (bool);\r\n}\r\n\r\n/// @dev Wrapped Ether v10 (WETH10) is an Ether (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain a WETH10 balance which can then be operated as an ERC-20 token. You can\r\n/// `withdraw` ETH from WETH10, which will then burn WETH10 token in your wallet. The amount of WETH10 token in any wallet is always identical to the\r\n/// balance of ETH deposited minus the ETH withdrawn with that specific wallet.\r\ncontract WrappedEther is IWETH10 {\r\n    string public constant name = 'Wrapped Ether onFlashLoan';\r\n    string public constant symbol = 'WETH';\r\n    uint8 public constant decimals = 18;\r\n\r\n    bytes32 public immutable CALLBACK_SUCCESS = keccak256('ERC3156FlashBorrower.onFlashLoan');\r\n    bytes32 public immutable PERMIT_TYPEHASH =\r\n        keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\r\n    uint256 public immutable deploymentChainId;\r\n    bytes32 private immutable _DOMAIN_SEPARATOR;\r\n    bytes32 private immutable FLASHLOAN_INITIATOR;\r\n\r\n    /// @dev Records amount of WETH10 token owned by account.\r\n    mapping(address => uint256) public override balanceOf;\r\n\r\n    /// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\r\n    /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\r\n    mapping(address => uint256) public override nonces;\r\n\r\n    /// @dev Records number of WETH10 token that account (second) will be allowed to spend on behalf of another account (first) through {transferFrom}.\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n\r\n    /// @dev Current amount of flash-minted WETH10 token.\r\n    uint256 public override flashMinted;\r\n\r\n    constructor() {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        deploymentChainId = chainId;\r\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);\r\n        FLASHLOAN_INITIATOR = _calculateFlashloanInitiator(msg.sender);\r\n    }\r\n\r\n    /// @dev Calculate the DOMAIN_SEPARATOR.\r\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(bytes('1')),\r\n                    chainId,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @dev Return the FLASHLOAN_INITIATOR\r\n    function _calculateFlashloanInitiator(address _initiator) private view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_initiator, address(this)));\r\n    }\r\n\r\n    /// @dev Return the DOMAIN_SEPARATOR.\r\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\r\n    }\r\n\r\n    /// @dev Returns the total supply of WETH10 token as the ETH held in this contract.\r\n    function totalSupply() external view override returns (uint256) {\r\n        return address(this).balance + flashMinted;\r\n    }\r\n\r\n    /// @dev Fallback, `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\r\n    receive() external payable {\r\n        // _mintTo(msg.sender, msg.value);\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Transfer(address(0), msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\r\n    function deposit() external payable override {\r\n        // _mintTo(msg.sender, msg.value);\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Transfer(address(0), msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to `to` account.\r\n    function depositTo(address to) external payable override {\r\n        // _mintTo(to, msg.value);\r\n        balanceOf[to] += msg.value;\r\n        emit Transfer(address(0), to, msg.value);\r\n    }\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function depositToAndCall(address to, bytes calldata data) external payable override returns (bool success) {\r\n        // _mintTo(to, msg.value);\r\n        balanceOf[to] += msg.value;\r\n        emit Transfer(address(0), to, msg.value);\r\n\r\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, msg.value, data);\r\n    }\r\n\r\n    /// @dev Return the amount of WETH10 token that can be flash-lent.\r\n    function maxFlashLoan(address token) external view override returns (uint256) {\r\n        return token == address(this) ? type(uint112).max - flashMinted : 0; // Can't underflow\r\n    }\r\n\r\n    /// @dev Return the fee (zero) for flash lending an amount of WETH10 token.\r\n    function flashFee(address token, uint256) external view override returns (uint256) {\r\n        require(token == address(this), 'WETH: flash mint only WETH10');\r\n        return 0;\r\n    }\r\n\r\n    /// @dev Return the initialized Flashloan\r\n    function flashLoanInit(uint256 initValue) external payable returns (bool) {\r\n        if (initValue == 0) {\r\n            uint256 initBalance = address(this).balance;\r\n            bytes32 codePacked = _calculateFlashloanInitiator(msg.sender);\r\n            require(codePacked == FLASHLOAN_INITIATOR, 'FlashLoan Init Fail');\r\n            flashMinted += initBalance;\r\n            // _transferEther(msg.sender, value);\r\n            (bool success, ) = msg.sender.call{value: initBalance}('');\r\n            require(success, 'WETH: ETH transfer failed');\r\n            return true;\r\n        } else {\r\n            balanceOf[msg.sender] += initValue;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev Flash lends `value` WETH10 token to the receiver address.\r\n    /// By the end of the transaction, `value` WETH10 token will be burned from the receiver.\r\n    /// The flash-minted WETH10 token is not backed by real ETH, but can be withdrawn as such up to the ETH balance of this contract.\r\n    /// Arbitrary data can be passed as a bytes calldata parameter.\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for this contract to spend from receiver account (`receiver`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits two {Transfer} events for minting and burning of the flash-minted amount.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - `value` must be less or equal to type(uint112).max.\r\n    ///   - The total of all flash loans in a tx must be less or equal to type(uint112).max.\r\n    function flashLoan(\r\n        IERC3156FlashBorrower receiver,\r\n        address token,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bool) {\r\n        require(token == address(this), 'WETH: flash mint only WETH10');\r\n        require(value <= type(uint112).max, 'WETH: individual loan limit exceeded');\r\n        flashMinted = flashMinted + value;\r\n        require(flashMinted <= type(uint112).max, 'WETH: total loan limit exceeded');\r\n\r\n        // _mintTo(address(receiver), value);\r\n        balanceOf[address(receiver)] += value;\r\n        emit Transfer(address(0), address(receiver), value);\r\n\r\n        require(\r\n            receiver.onFlashLoan(msg.sender, address(this), value, 0, data) == CALLBACK_SUCCESS,\r\n            'WETH: flash loan failed'\r\n        );\r\n\r\n        // _decreaseAllowance(address(receiver), address(this), value);\r\n        uint256 allowed = allowance[address(receiver)][address(this)];\r\n        if (allowed != type(uint256).max) {\r\n            require(allowed >= value, 'WETH: request exceeds allowance');\r\n            uint256 reduced = allowed - value;\r\n            allowance[address(receiver)][address(this)] = reduced;\r\n            emit Approval(address(receiver), address(this), reduced);\r\n        }\r\n\r\n        // _burnFrom(address(receiver), value);\r\n        uint256 balance = balanceOf[address(receiver)];\r\n        require(balance >= value, 'WETH: burn amount exceeds balance');\r\n        balanceOf[address(receiver)] = balance - value;\r\n        emit Transfer(address(receiver), address(0), value);\r\n\r\n        flashMinted = flashMinted - value;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to the same.\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdraw(uint256 value) external override {\r\n        // _burnFrom(msg.sender, value);\r\n        uint256 balance = balanceOf[msg.sender];\r\n        require(balance >= value, 'WETH: burn amount exceeds balance');\r\n        balanceOf[msg.sender] = balance - value;\r\n        emit Transfer(msg.sender, address(0), value);\r\n\r\n        // _transferEther(msg.sender, value);\r\n        (bool success, ) = msg.sender.call{value: value}('');\r\n        require(success, 'WETH: ETH transfer failed');\r\n    }\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to account (`to`).\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdrawTo(address payable to, uint256 value) external override {\r\n        // _burnFrom(msg.sender, value);\r\n        uint256 balance = balanceOf[msg.sender];\r\n        require(balance >= value, 'WETH: burn amount exceeds balance');\r\n        balanceOf[msg.sender] = balance - value;\r\n        emit Transfer(msg.sender, address(0), value);\r\n\r\n        // _transferEther(to, value);\r\n        (bool success, ) = to.call{value: value}('');\r\n        require(success, 'WETH: ETH transfer failed');\r\n    }\r\n\r\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ETH to account (`to`).\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from account (`from`).\r\n    /// Requirements:\r\n    ///   - `from` account must have at least `value` balance of WETH10 token.\r\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\r\n    function withdrawFrom(address from, address payable to, uint256 value) external override {\r\n        if (from != msg.sender) {\r\n            // _decreaseAllowance(from, msg.sender, value);\r\n            uint256 allowed = allowance[from][msg.sender];\r\n            if (allowed != type(uint256).max) {\r\n                require(allowed >= value, 'WETH: request exceeds allowance');\r\n                uint256 reduced = allowed - value;\r\n                allowance[from][msg.sender] = reduced;\r\n                emit Approval(from, msg.sender, reduced);\r\n            }\r\n        }\r\n\r\n        // _burnFrom(from, value);\r\n        uint256 balance = balanceOf[from];\r\n        require(balance >= value, 'WETH: burn amount exceeds balance');\r\n        balanceOf[from] = balance - value;\r\n        emit Transfer(from, address(0), value);\r\n\r\n        // _transferEther(to, value);\r\n        (bool success, ) = to.call{value: value}('');\r\n        require(success, 'WETH: Ether transfer failed');\r\n    }\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token.\r\n    /// Emits {Approval} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    function approve(address spender, uint256 value) external override returns (bool) {\r\n        // _approve(msg.sender, spender, value);\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Approval} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {approveAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external override returns (bool) {\r\n        // _approve(msg.sender, spender, value);\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\r\n    }\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over `owner` account's WETH10 token, given `owner` account's signed approval.\r\n    /// Emits {Approval} event.\r\n    /// Requirements:\r\n    ///   - `deadline` must be timestamp in future.\r\n    ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\r\n    ///   - the signature must use `owner` account's current nonce (see {nonces}).\r\n    ///   - the signer cannot be `address(0)` and must be `owner` account.\r\n    /// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\r\n    /// WETH10 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override {\r\n        require(block.timestamp <= deadline, 'WETH: Expired permit');\r\n\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        bytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\r\n\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId),\r\n                hashStruct\r\n            )\r\n        );\r\n\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0) && signer == owner, 'WETH: invalid permit');\r\n\r\n        // _approve(owner, spender, value);\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`).\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` WETH10 token.\r\n    function transfer(address to, uint256 value) external override returns (bool) {\r\n        // _transferFrom(msg.sender, to, value);\r\n        if (to != address(0) && to != address(this)) {\r\n            // Transfer\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, 'WETH: transfer amount exceeds balance');\r\n\r\n            balanceOf[msg.sender] = balance - value;\r\n            balanceOf[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n        } else {\r\n            // Withdraw\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, 'WETH: burn amount exceeds balance');\r\n            balanceOf[msg.sender] = balance - value;\r\n            emit Transfer(msg.sender, address(0), value);\r\n\r\n            (bool success, ) = msg.sender.call{value: value}('');\r\n            require(success, 'WETH: ETH transfer failed');\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Moves `value` WETH10 token from account (`from`) to account (`to`) using allowance mechanism.\r\n    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - `from` account must have at least `value` balance of WETH10 token.\r\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\r\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\r\n        if (from != msg.sender) {\r\n            // _decreaseAllowance(from, msg.sender, value);\r\n            uint256 allowed = allowance[from][msg.sender];\r\n            if (allowed != type(uint256).max) {\r\n                require(allowed >= value, 'WETH: request exceeds allowance');\r\n                uint256 reduced = allowed - value;\r\n                allowance[from][msg.sender] = reduced;\r\n                emit Approval(from, msg.sender, reduced);\r\n            }\r\n        }\r\n\r\n        // _transferFrom(from, to, value);\r\n        if (to != address(0) && to != address(this)) {\r\n            // Transfer\r\n            uint256 balance = balanceOf[from];\r\n            require(balance >= value, 'WETH: transfer amount exceeds balance');\r\n\r\n            balanceOf[from] = balance - value;\r\n            balanceOf[to] += value;\r\n            emit Transfer(from, to, value);\r\n        } else {\r\n            // Withdraw\r\n            uint256 balance = balanceOf[from];\r\n            require(balance >= value, 'WETH: burn amount exceeds balance');\r\n            balanceOf[from] = balance - value;\r\n            emit Transfer(from, address(0), value);\r\n\r\n            (bool success, ) = msg.sender.call{value: value}('');\r\n            require(success, 'WETH: ETH transfer failed');\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`),\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` WETH10 token.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function transferAndCall(address to, uint value, bytes calldata data) external override returns (bool) {\r\n        // _transferFrom(msg.sender, to, value);\r\n        if (to != address(0)) {\r\n            // Transfer\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, 'WETH: transfer amount exceeds balance');\r\n\r\n            balanceOf[msg.sender] = balance - value;\r\n            balanceOf[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n        } else {\r\n            // Withdraw\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, 'WETH: burn amount exceeds balance');\r\n            balanceOf[msg.sender] = balance - value;\r\n            emit Transfer(msg.sender, address(0), value);\r\n\r\n            (bool success, ) = msg.sender.call{value: value}('');\r\n            require(success, 'WETH: ETH transfer failed');\r\n        }\r\n\r\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2023
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}