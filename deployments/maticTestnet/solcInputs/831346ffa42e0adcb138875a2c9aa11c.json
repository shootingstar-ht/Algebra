{
  "language": "Solidity",
  "sources": {
    "@alkaswap/core/contracts/base/AlgebraFeeConfiguration.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n// coefficients for sigmoids: α / (1 + e^( (β-x) / γ))\r\n// alpha1 + alpha2 + baseFee must be <= type(uint16).max\r\nstruct AlgebraFeeConfiguration {\r\n  uint16 alpha1; // max value of the first sigmoid\r\n  uint16 alpha2; // max value of the second sigmoid\r\n  uint32 beta1; // shift along the x-axis for the first sigmoid\r\n  uint32 beta2; // shift along the x-axis for the second sigmoid\r\n  uint16 gamma1; // horizontal stretch factor for the first sigmoid\r\n  uint16 gamma2; // horizontal stretch factor for the second sigmoid\r\n  uint16 baseFee; // minimum possible fee\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/callback/IAlgebraMintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Callback for IAlgebraPoolActions#mint\r\n/// @notice Any contract that calls IAlgebraPoolActions#mint must implement this interface\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraMintCallback {\r\n  /// @notice Called to `msg.sender` after minting liquidity to a position from IAlgebraPool#mint.\r\n  /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\r\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\r\n  /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\r\n  /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\r\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#mint call\r\n  function algebraMintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external;\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/callback/IAlgebraSwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Callback for IAlgebraPoolActions#swap\r\n/// @notice Any contract that calls IAlgebraPoolActions#swap must implement this interface\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraSwapCallback {\r\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\r\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\r\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\r\n  function algebraSwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/IAlgebraFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\npragma abicoder v2;\r\n\r\nimport '../base/AlgebraFeeConfiguration.sol';\r\n\r\n/// @title The interface for the Algebra Factory\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraFactory {\r\n  /// @notice Emitted when a process of ownership renounce is started\r\n  /// @param timestamp The timestamp of event\r\n  /// @param finishTimestamp The timestamp when ownership renounce will be possible to finish\r\n  event RenounceOwnershipStart(uint256 timestamp, uint256 finishTimestamp);\r\n\r\n  /// @notice Emitted when a process of ownership renounce cancelled\r\n  /// @param timestamp The timestamp of event\r\n  event RenounceOwnershipStop(uint256 timestamp);\r\n\r\n  /// @notice Emitted when a process of ownership renounce finished\r\n  /// @param timestamp The timestamp of ownership renouncement\r\n  event RenounceOwnershipFinish(uint256 timestamp);\r\n\r\n  /// @notice Emitted when a pool is created\r\n  /// @param token0 The first token of the pool by address sort order\r\n  /// @param token1 The second token of the pool by address sort order\r\n  /// @param pool The address of the created pool\r\n  event Pool(address indexed token0, address indexed token1, address pool);\r\n\r\n  /// @notice Emitted when the farming address is changed\r\n  /// @param newFarmingAddress The farming address after the address was changed\r\n  event FarmingAddress(address indexed newFarmingAddress);\r\n\r\n  /// @notice Emitted when the default fee configuration is changed\r\n  /// @param newConfig The structure with dynamic fee parameters\r\n  /// @dev See the AdaptiveFee library for more details\r\n  event DefaultFeeConfiguration(AlgebraFeeConfiguration newConfig);\r\n\r\n  /// @notice Emitted when the default community fee is changed\r\n  /// @param newDefaultCommunityFee The new default community fee value\r\n  event DefaultCommunityFee(uint8 newDefaultCommunityFee);\r\n\r\n  /// @notice role that can change communityFee and tickspacing in pools\r\n  function POOLS_ADMINISTRATOR_ROLE() external view returns (bytes32);\r\n\r\n  /// @dev Returns `true` if `account` has been granted `role` or `account` is owner.\r\n  function hasRoleOrOwner(bytes32 role, address account) external view returns (bool);\r\n\r\n  /// @notice Returns the current owner of the factory\r\n  /// @dev Can be changed by the current owner via transferOwnership(address newOwner)\r\n  /// @return The address of the factory owner\r\n  function owner() external view returns (address);\r\n\r\n  /// @notice Returns the current poolDeployerAddress\r\n  /// @return The address of the poolDeployer\r\n  function poolDeployer() external view returns (address);\r\n\r\n  /// @dev Is retrieved from the pools to restrict calling certain functions not by a tokenomics contract\r\n  /// @return The tokenomics contract address\r\n  function farmingAddress() external view returns (address);\r\n\r\n  /// @notice Returns the current communityVaultAddress\r\n  /// @return The address to which community fees are transferred\r\n  function communityVault() external view returns (address);\r\n\r\n  /// @notice Returns the default community fee\r\n  /// @return Fee which will be set at the creation of the pool\r\n  function defaultCommunityFee() external view returns (uint8);\r\n\r\n  /// @notice Returns the pool address for a given pair of tokens, or address 0 if it does not exist\r\n  /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n  /// @param tokenA The contract address of either token0 or token1\r\n  /// @param tokenB The contract address of the other token\r\n  /// @return pool The pool address\r\n  function poolByPair(address tokenA, address tokenB) external view returns (address pool);\r\n\r\n  /// @return timestamp The timestamp of the beginning of the renounceOwnership process\r\n  function renounceOwnershipStartTimestamp() external view returns (uint256 timestamp);\r\n\r\n  /// @notice Creates a pool for the given two tokens\r\n  /// @param tokenA One of the two tokens in the desired pool\r\n  /// @param tokenB The other of the two tokens in the desired pool\r\n  /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0.\r\n  /// The call will revert if the pool already exists or the token arguments are invalid.\r\n  /// @return pool The address of the newly created pool\r\n  function createPool(address tokenA, address tokenB) external returns (address pool);\r\n\r\n  /// @dev updates tokenomics address on the factory\r\n  /// @param newFarmingAddress The new tokenomics contract address\r\n  function setFarmingAddress(address newFarmingAddress) external;\r\n\r\n  /// @dev updates default community fee for new pools\r\n  /// @param newDefaultCommunityFee The new community fee, _must_ be <= MAX_COMMUNITY_FEE\r\n  function setDefaultCommunityFee(uint8 newDefaultCommunityFee) external;\r\n\r\n  /// @notice Changes initial fee configuration for new pools\r\n  /// @dev changes coefficients for sigmoids: α / (1 + e^( (β-x) / γ))\r\n  /// alpha1 + alpha2 + baseFee (max possible fee) must be <= type(uint16).max and gammas must be > 0\r\n  /// @param newConfig new default fee configuration. See the #AdaptiveFee.sol library for details\r\n  function setDefaultFeeConfiguration(AlgebraFeeConfiguration calldata newConfig) external;\r\n\r\n  /// @notice Starts process of renounceOwnership. After that, a certain period\r\n  /// of time must pass before the ownership renounce can be completed.\r\n  function startRenounceOwnership() external;\r\n\r\n  /// @notice Stops process of renounceOwnership and removes timer.\r\n  function stopRenounceOwnership() external;\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/IAlgebraPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\nimport './pool/IAlgebraPoolImmutables.sol';\r\nimport './pool/IAlgebraPoolState.sol';\r\nimport './pool/IAlgebraPoolDerivedState.sol';\r\nimport './pool/IAlgebraPoolActions.sol';\r\nimport './pool/IAlgebraPoolPermissionedActions.sol';\r\nimport './pool/IAlgebraPoolEvents.sol';\r\n\r\n/// @title The interface for a Algebra Pool\r\n/// @dev The pool interface is broken up into many smaller pieces.\r\n/// Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPool is\r\n  IAlgebraPoolImmutables,\r\n  IAlgebraPoolState,\r\n  IAlgebraPoolDerivedState,\r\n  IAlgebraPoolActions,\r\n  IAlgebraPoolPermissionedActions,\r\n  IAlgebraPoolEvents\r\n{\r\n  // used only for combining interfaces\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/IAlgebraPoolErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.4 <0.9.0;\r\n\r\n/// @title Errors emitted by a pool\r\n/// @notice Contains custom errors emitted by the pool\r\ninterface IAlgebraPoolErrors {\r\n  // ####  pool errors  ####\r\n\r\n  /// @notice Emitted by the reentrancy guard\r\n  error locked();\r\n\r\n  /// @notice Emitted if arithmetic error occurred\r\n  error arithmeticError();\r\n\r\n  /// @notice Emitted if an attempt is made to initialize the pool twice\r\n  error alreadyInitialized();\r\n\r\n  /// @notice Emitted if 0 is passed as amountRequired to swap function\r\n  error zeroAmountRequired();\r\n\r\n  /// @notice Emitted if invalid amount is passed as amountRequired to swapSupportingFeeOnInputTokens function\r\n  error invalidAmountRequired();\r\n\r\n  /// @notice Emitted if the pool received fewer tokens than it should have\r\n  error insufficientInputAmount();\r\n  /// @notice Emitted if the pool received fewer tokens than it should have to mint calculated actual liquidity\r\n  error insufficientAmountReceivedAtMint();\r\n\r\n  /// @notice Emitted if there was an attempt to mint zero liquidity\r\n  error zeroLiquidityDesired();\r\n  /// @notice Emitted if actual amount of liquidity is zero (due to insufficient amount of tokens received)\r\n  error zeroLiquidityActual();\r\n\r\n  /// @notice Emitted if the pool received fewer tokens{0,1} after flash than it should have\r\n  error flashInsufficientPaid0();\r\n  error flashInsufficientPaid1();\r\n\r\n  /// @notice Emitted if limitSqrtPrice param is incorrect\r\n  error invalidLimitSqrtPrice();\r\n\r\n  /// @notice Tick must be divisible by tickspacing\r\n  error tickIsNotSpaced();\r\n\r\n  /// @notice Emitted if a method is called that is accessible only to the factory owner or dedicated role\r\n  error notAllowed();\r\n  /// @notice Emitted if a method is called that is accessible only to the farming\r\n  error onlyFarming();\r\n\r\n  error invalidNewTickSpacing();\r\n  error invalidNewCommunityFee();\r\n\r\n  // ####  LimitOrder errors  ####\r\n  /// @notice Emitted if tick is too low/high for limit order\r\n  error invalidTickForLimitOrder();\r\n  /// @notice Emitted if amount is too high for limit order\r\n  error invalidAmountForLimitOrder();\r\n\r\n  // ####  LiquidityMath errors  ####\r\n  /// @notice Emitted if liquidity underflows\r\n  error liquiditySub();\r\n  /// @notice Emitted if liquidity overflows\r\n  error liquidityAdd();\r\n\r\n  // ####  TickManagement errors  ####\r\n  error topTickLowerThanBottomTick();\r\n  error bottomTickLowerThanMIN();\r\n  error topTickAboveMAX();\r\n  error liquidityOverflow();\r\n  error tickIsNotInitialized();\r\n  error tickInvalidLinks();\r\n\r\n  // ####  SafeTransfer errors  ####\r\n  error transferFailed();\r\n\r\n  // ####  TickMath errors  ####\r\n  error tickOutOfRange();\r\n  error priceOutOfRange();\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/IDataStorageOperator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\npragma abicoder v2;\r\n\r\nimport '../base/AlgebraFeeConfiguration.sol';\r\n\r\n/// @title The interface for the DataStorageOperator\r\n/// @dev This contract stores timepoints and calculates adaptive fee and statistical averages\r\ninterface IDataStorageOperator {\r\n  /// @notice Emitted when the fee configuration is changed\r\n  /// @param feeConfig The structure with dynamic fee parameters\r\n  /// @dev See the AdaptiveFee library for more details\r\n  event FeeConfiguration(AlgebraFeeConfiguration feeConfig);\r\n\r\n  /// @notice Returns data belonging to a certain timepoint\r\n  /// @param index The index of timepoint in the array\r\n  /// @dev There is more convenient function to fetch a timepoint: getTimepoints(). Which requires not an index but seconds\r\n  /// @return initialized Whether the timepoint has been initialized and the values are safe to use\r\n  /// @return blockTimestamp The timestamp of the timepoint\r\n  /// @return tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\r\n  /// @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\r\n  /// @return tick The tick at blockTimestamp\r\n  /// @return averageTick Time-weighted average tick\r\n  /// @return windowStartIndex Index of closest timepoint >= WINDOW seconds ago\r\n  function timepoints(\r\n    uint256 index\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      bool initialized,\r\n      uint32 blockTimestamp,\r\n      int56 tickCumulative,\r\n      uint88 volatilityCumulative,\r\n      int24 tick,\r\n      int24 averageTick,\r\n      uint16 windowStartIndex\r\n    );\r\n\r\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\r\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\r\n  /// @param tick Initial tick\r\n  function initialize(uint32 time, int24 tick) external;\r\n\r\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\r\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\r\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\r\n  /// at exactly the timestamp between the two timepoints.\r\n  /// @param time The current block timestamp\r\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\r\n  /// @param tick The current tick\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\r\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\r\n  function getSingleTimepoint(\r\n    uint32 time,\r\n    uint32 secondsAgo,\r\n    int24 tick,\r\n    uint16 index\r\n  ) external view returns (int56 tickCumulative, uint112 volatilityCumulative);\r\n\r\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\r\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\r\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\r\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\r\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\r\n  function getTimepoints(uint32[] memory secondsAgos) external view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives);\r\n\r\n  /// @notice Writes a dataStorage timepoint to the array\r\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param blockTimestamp The timestamp of the new timepoint\r\n  /// @param tick The active tick at the time of the new timepoint\r\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\r\n  /// @return newFee The fee in hundredths of a bip, i.e. 1e-6\r\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external returns (uint16 indexUpdated, uint16 newFee);\r\n\r\n  /// @notice Changes fee configuration for the pool\r\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata feeConfig) external;\r\n\r\n  /// @notice Fills uninitialized timepoints with nonzero value\r\n  /// @dev Can be used to reduce the gas cost of future swaps\r\n  /// @param startIndex The start index, must be not initialized\r\n  /// @param amount of slots to fill, startIndex + amount must be <= type(uint16).max\r\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external;\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/pool/IAlgebraPoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Permissionless pool actions\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolActions {\r\n  /// @notice Sets the initial price for the pool\r\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\r\n  /// @dev Initialization should be done in one transaction with pool creation to avoid front-running\r\n  /// @param price the initial sqrt price of the pool as a Q64.96\r\n  function initialize(uint160 price) external;\r\n\r\n  /// @notice Adds liquidity for the given recipient/bottomTick/topTick position\r\n  /// @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\r\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\r\n  /// on bottomTick, topTick, the amount of liquidity, and the current price. If bottomTick == topTick position is treated as a limit order\r\n  /// @param sender The address which will receive potential surplus of paid tokens\r\n  /// @param recipient The address for which the liquidity will be created\r\n  /// @param bottomTick The lower tick of the position in which to add liquidity\r\n  /// @param topTick The upper tick of the position in which to add liquidity\r\n  /// @param amount The desired amount of liquidity to mint\r\n  /// @param data Any data that should be passed through to the callback\r\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n  /// @return liquidityActual The actual minted amount of liquidity\r\n  function mint(\r\n    address sender,\r\n    address recipient,\r\n    int24 bottomTick,\r\n    int24 topTick,\r\n    uint128 amount,\r\n    bytes calldata data\r\n  ) external returns (uint256 amount0, uint256 amount1, uint128 liquidityActual);\r\n\r\n  /// @notice Collects tokens owed to a position\r\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\r\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\r\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\r\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\r\n  /// @param recipient The address which should receive the fees collected\r\n  /// @param bottomTick The lower tick of the position for which to collect fees\r\n  /// @param topTick The upper tick of the position for which to collect fees\r\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\r\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\r\n  /// @return amount0 The amount of fees collected in token0\r\n  /// @return amount1 The amount of fees collected in token1\r\n  function collect(\r\n    address recipient,\r\n    int24 bottomTick,\r\n    int24 topTick,\r\n    uint128 amount0Requested,\r\n    uint128 amount1Requested\r\n  ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\r\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\r\n  /// @dev Fees must be collected separately via a call to #collect\r\n  /// @param bottomTick The lower tick of the position for which to burn liquidity\r\n  /// @param topTick The upper tick of the position for which to burn liquidity\r\n  /// @param amount How much liquidity to burn\r\n  /// @return amount0 The amount of token0 sent to the recipient\r\n  /// @return amount1 The amount of token1 sent to the recipient\r\n  function burn(int24 bottomTick, int24 topTick, uint128 amount) external returns (uint256 amount0, uint256 amount1);\r\n\r\n  /// @notice Swap token0 for token1, or token1 for token0\r\n  /// @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback#AlgebraSwapCallback\r\n  /// @param recipient The address to receive the output of the swap\r\n  /// @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\r\n  /// @param amountRequired The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\r\n  /// @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\r\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\r\n  /// @param data Any data to be passed through to the callback. If using the Router it should contain SwapRouter#SwapCallbackData\r\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\r\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\r\n  function swap(\r\n    address recipient,\r\n    bool zeroToOne,\r\n    int256 amountRequired,\r\n    uint160 limitSqrtPrice,\r\n    bytes calldata data\r\n  ) external returns (int256 amount0, int256 amount1);\r\n\r\n  /// @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\r\n  /// @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback#AlgebraSwapCallback\r\n  /// @param sender The address called this function (Comes from the Router)\r\n  /// @param recipient The address to receive the output of the swap\r\n  /// @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\r\n  /// @param amountRequired The amount of the swap, which implicitly configures the swap as exact input\r\n  /// @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\r\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\r\n  /// @param data Any data to be passed through to the callback. If using the Router it should contain SwapRouter#SwapCallbackData\r\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\r\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\r\n  function swapSupportingFeeOnInputTokens(\r\n    address sender,\r\n    address recipient,\r\n    bool zeroToOne,\r\n    int256 amountRequired,\r\n    uint160 limitSqrtPrice,\r\n    bytes calldata data\r\n  ) external returns (int256 amount0, int256 amount1);\r\n\r\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\r\n  /// @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback#AlgebraFlashCallback\r\n  /// @dev All excess tokens paid in the callback are distributed to currently in-range liquidity providers as an additional fee.\r\n  /// If there are no in-range liquidity providers, the fee will be transferred to the first active provider in the future\r\n  /// @param recipient The address which will receive the token0 and token1 amounts\r\n  /// @param amount0 The amount of token0 to send\r\n  /// @param amount1 The amount of token1 to send\r\n  /// @param data Any data to be passed through to the callback\r\n  function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/pool/IAlgebraPoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Pool state that is not stored\r\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\r\n/// blockchain. The functions here may have variable gas costs.\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolDerivedState {\r\n  /// @notice Returns a snapshot of seconds per liquidity and seconds inside a tick range\r\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\r\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\r\n  /// snapshot is taken and the second snapshot is taken.\r\n  /// @param bottomTick The lower tick of the range\r\n  /// @param topTick The upper tick of the range\r\n  /// @return innerSecondsSpentPerLiquidity The snapshot of seconds per liquidity for the range\r\n  /// @return innerSecondsSpent The snapshot of the number of seconds during which the price was in this range\r\n  function getInnerCumulatives(\r\n    int24 bottomTick,\r\n    int24 topTick\r\n  ) external view returns (uint160 innerSecondsSpentPerLiquidity, uint32 innerSecondsSpent);\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/pool/IAlgebraPoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Events emitted by a pool\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolEvents {\r\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\r\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\r\n  /// @param price The initial sqrt price of the pool, as a Q64.96\r\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\r\n  event Initialize(uint160 price, int24 tick);\r\n\r\n  /// @notice Emitted when liquidity is minted for a given position\r\n  /// @dev If the top and bottom ticks match, this should be treated as a limit order\r\n  /// @param sender The address that minted the liquidity\r\n  /// @param owner The owner of the position and recipient of any minted liquidity\r\n  /// @param bottomTick The lower tick of the position\r\n  /// @param topTick The upper tick of the position\r\n  /// @param liquidityAmount The amount of liquidity minted to the position range\r\n  /// @param amount0 How much token0 was required for the minted liquidity\r\n  /// @param amount1 How much token1 was required for the minted liquidity\r\n  event Mint(\r\n    address sender,\r\n    address indexed owner,\r\n    int24 indexed bottomTick,\r\n    int24 indexed topTick,\r\n    uint128 liquidityAmount,\r\n    uint256 amount0,\r\n    uint256 amount1\r\n  );\r\n\r\n  /// @notice Emitted when fees are collected by the owner of a position\r\n  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\r\n  /// @param owner The owner of the position for which fees are collected\r\n  /// @param recipient The address that received fees\r\n  /// @param bottomTick The lower tick of the position\r\n  /// @param topTick The upper tick of the position\r\n  /// @param amount0 The amount of token0 fees collected\r\n  /// @param amount1 The amount of token1 fees collected\r\n  event Collect(address indexed owner, address recipient, int24 indexed bottomTick, int24 indexed topTick, uint128 amount0, uint128 amount1);\r\n\r\n  /// @notice Emitted when a position's liquidity is removed\r\n  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\r\n  /// @param owner The owner of the position for which liquidity is removed\r\n  /// @param bottomTick The lower tick of the position\r\n  /// @param topTick The upper tick of the position\r\n  /// @param liquidityAmount The amount of liquidity to remove\r\n  /// @param amount0 The amount of token0 withdrawn\r\n  /// @param amount1 The amount of token1 withdrawn\r\n  event Burn(address indexed owner, int24 indexed bottomTick, int24 indexed topTick, uint128 liquidityAmount, uint256 amount0, uint256 amount1);\r\n\r\n  /// @notice Emitted by the pool for any swaps between token0 and token1\r\n  /// @param sender The address that initiated the swap call, and that received the callback\r\n  /// @param recipient The address that received the output of the swap\r\n  /// @param amount0 The delta of the token0 balance of the pool\r\n  /// @param amount1 The delta of the token1 balance of the pool\r\n  /// @param price The sqrt(price) of the pool after the swap, as a Q64.96\r\n  /// @param liquidity The liquidity of the pool after the swap\r\n  /// @param tick The log base 1.0001 of price of the pool after the swap\r\n  event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 price, uint128 liquidity, int24 tick);\r\n\r\n  /// @notice Emitted by the pool for any flashes of token0/token1\r\n  /// @param sender The address that initiated the swap call, and that received the callback\r\n  /// @param recipient The address that received the tokens from flash\r\n  /// @param amount0 The amount of token0 that was flashed\r\n  /// @param amount1 The amount of token1 that was flashed\r\n  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\r\n  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\r\n  event Flash(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\r\n\r\n  /// @notice Emitted when the community fee is changed by the pool\r\n  /// @param communityFeeNew The updated value of the community fee in thousandths (1e-3)\r\n  event CommunityFee(uint8 communityFeeNew);\r\n\r\n  /// @notice Emitted when the tick spacing changes\r\n  /// @param newTickSpacing The updated value of the new tick spacing\r\n  /// @param newTickSpacingLimitOrders The updated value of the new tick spacing for limit orders\r\n  event TickSpacing(int24 newTickSpacing, int24 newTickSpacingLimitOrders);\r\n\r\n  /// @notice Emitted when new activeIncentive is set\r\n  /// @param newIncentiveAddress The address of the new incentive\r\n  event Incentive(address indexed newIncentiveAddress);\r\n\r\n  /// @notice Emitted when the fee changes inside the pool\r\n  /// @param fee The current fee in hundredths of a bip, i.e. 1e-6\r\n  event Fee(uint16 fee);\r\n\r\n  /// @notice Emitted in case of an error when trying to write to the DataStorage\r\n  /// @dev This shouldn't happen\r\n  event DataStorageFailure();\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/pool/IAlgebraPoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Pool state that never changes\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolImmutables {\r\n  /// @notice The contract that stores all the timepoints and can perform actions with them\r\n  /// @return The operator address\r\n  function dataStorageOperator() external view returns (address);\r\n\r\n  /// @notice The contract that deployed the pool, which must adhere to the IAlgebraFactory interface\r\n  /// @return The contract address\r\n  function factory() external view returns (address);\r\n\r\n  /// @notice The first of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token0() external view returns (address);\r\n\r\n  /// @notice The second of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token1() external view returns (address);\r\n\r\n  /// @notice The contract to which community fees are transferred\r\n  /// @return The communityVault address\r\n  function communityVault() external view returns (address);\r\n\r\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\r\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\r\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\r\n  /// @return The max amount of liquidity per tick\r\n  function maxLiquidityPerTick() external view returns (uint128);\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/pool/IAlgebraPoolPermissionedActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Permissioned pool actions\r\n/// @notice Contains pool methods that may only be called by permissioned addresses\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolPermissionedActions {\r\n  /// @notice Set the community's % share of the fees. Cannot exceed 25% (250). Only factory owner or POOLS_ADMINISTRATOR_ROLE role\r\n  /// @param communityFee new community fee percent in thousandths (1e-3)\r\n  function setCommunityFee(uint8 communityFee) external;\r\n\r\n  /// @notice Set the new tick spacing values. Only factory owner or POOLS_ADMINISTRATOR_ROLE role\r\n  /// @param newTickSpacing The new tick spacing value\r\n  /// @param newTickSpacingLimitOrders The new tick spacing value for limit orders\r\n  function setTickSpacing(int24 newTickSpacing, int24 newTickSpacingLimitOrders) external;\r\n\r\n  /// @notice Sets an active incentive. Only farming\r\n  /// @param newIncentiveAddress The address associated with the incentive\r\n  function setIncentive(address newIncentiveAddress) external;\r\n}\r\n"
    },
    "@alkaswap/core/contracts/interfaces/pool/IAlgebraPoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Pool state that can change\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\r\ninterface IAlgebraPoolState {\r\n  /// @notice The globalState structure in the pool stores many values but requires only one slot\r\n  /// and is exposed as a single method to save gas when accessed externally.\r\n  /// @return price The current price of the pool as a sqrt(dToken1/dToken0) Q64.96 value;\r\n  /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run;\r\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick boundary;\r\n  /// @return prevInitializedTick The previous initialized tick\r\n  /// @return fee The last pool fee value in hundredths of a bip, i.e. 1e-6\r\n  /// @return timepointIndex The index of the last written timepoint\r\n  /// @return communityFee The community fee percentage of the swap fee in thousandths (1e-3)\r\n  /// @return unlocked Whether the pool is currently locked to reentrancy\r\n  function globalState()\r\n    external\r\n    view\r\n    returns (uint160 price, int24 tick, int24 prevInitializedTick, uint16 fee, uint16 timepointIndex, uint8 communityFee, bool unlocked);\r\n\r\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\r\n  /// @dev This value can overflow the uint256\r\n  function totalFeeGrowth0Token() external view returns (uint256);\r\n\r\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\r\n  /// @dev This value can overflow the uint256\r\n  function totalFeeGrowth1Token() external view returns (uint256);\r\n\r\n  /// @notice The currently in range liquidity available to the pool\r\n  /// @dev This value has no relationship to the total liquidity across all ticks.\r\n  /// Returned value cannot exceed type(uint128).max\r\n  function liquidity() external view returns (uint128);\r\n\r\n  /// @notice The current tick spacing\r\n  /// @dev Ticks can only be used at multiples of this value\r\n  /// e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\r\n  /// This value is an int24 to avoid casting even though it is always positive.\r\n  /// @return The current tick spacing\r\n  function tickSpacing() external view returns (int24);\r\n\r\n  /// @notice The current tick spacing for limit orders\r\n  /// @dev Ticks can only be used for limit orders at multiples of this value\r\n  /// This value is an int24 to avoid casting even though it is always positive.\r\n  /// @return The current tick spacing for limit orders\r\n  function tickSpacingLimitOrders() external view returns (int24);\r\n\r\n  /// @notice The timestamp of the last sending of tokens to community vault\r\n  function communityFeeLastTimestamp() external view returns (uint32);\r\n\r\n  /// @notice The amounts of token0 and token1 that will be sent to the vault\r\n  /// @dev Will be sent COMMUNITY_FEE_TRANSFER_FREQUENCY after communityFeeLastTimestamp\r\n  function getCommunityFeePending() external view returns (uint128 communityFeePending0, uint128 communityFeePending1);\r\n\r\n  /// @notice The tracked token0 and token1 reserves of pool\r\n  /// @dev If at any time the real balance is larger, the excess will be transferred to liquidity providers as additional fee.\r\n  /// If the balance exceeds uint128, the excess will be sent to the communityVault.\r\n  function getReserves() external view returns (uint128 reserve0, uint128 reserve1);\r\n\r\n  /// @notice The accumulator of seconds per liquidity since the pool was first initialized\r\n  function secondsPerLiquidityCumulative() external view returns (uint160);\r\n\r\n  /// @notice Look up information about a specific tick in the pool\r\n  /// @param tick The tick to look up\r\n  /// @return liquidityTotal The total amount of position liquidity that uses the pool either as tick lower or tick upper\r\n  /// @return liquidityDelta How much liquidity changes when the pool price crosses the tick\r\n  /// @return outerFeeGrowth0Token The fee growth on the other side of the tick from the current tick in token0\r\n  /// @return outerFeeGrowth1Token The fee growth on the other side of the tick from the current tick in token1\r\n  /// @return prevTick The previous tick in tick list\r\n  /// @return nextTick The next tick in tick list\r\n  /// @return outerSecondsPerLiquidity The seconds spent per liquidity on the other side of the tick from the current tick\r\n  /// @return outerSecondsSpent The seconds spent on the other side of the tick from the current tick\r\n  /// @return hasLimitOrders Whether there are limit orders on this tick or not\r\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\r\n  /// a specific position.\r\n  function ticks(\r\n    int24 tick\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint128 liquidityTotal,\r\n      int128 liquidityDelta,\r\n      uint256 outerFeeGrowth0Token,\r\n      uint256 outerFeeGrowth1Token,\r\n      int24 prevTick,\r\n      int24 nextTick,\r\n      uint160 outerSecondsPerLiquidity,\r\n      uint32 outerSecondsSpent,\r\n      bool hasLimitOrders\r\n    );\r\n\r\n  /// @notice Returns the summary information about a limit orders at tick\r\n  /// @param tick The tick to look up\r\n  /// @return amountToSell The amount of tokens to sell. Has only relative meaning\r\n  /// @return soldAmount The amount of tokens already sold. Has only relative meaning\r\n  /// @return boughtAmount0Cumulative The accumulator of bought tokens0 per amountToSell. Has only relative meaning\r\n  /// @return boughtAmount1Cumulative The accumulator of bought tokens1 per amountToSell. Has only relative meaning\r\n  /// @return initialized Will be true if a limit order was created at least once on this tick\r\n  function limitOrders(\r\n    int24 tick\r\n  )\r\n    external\r\n    view\r\n    returns (uint128 amountToSell, uint128 soldAmount, uint256 boughtAmount0Cumulative, uint256 boughtAmount1Cumulative, bool initialized);\r\n\r\n  /// @notice Returns 256 packed tick initialized boolean values. See TickTree for more information\r\n  function tickTable(int16 wordPosition) external view returns (uint256);\r\n\r\n  /// @notice Returns the information about a position by the position's key\r\n  /// @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\r\n  /// @return liquidity The amount of liquidity in the position\r\n  /// @return innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke\r\n  /// @return innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke\r\n  /// @return fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke\r\n  /// @return fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\r\n  function positions(\r\n    bytes32 key\r\n  ) external view returns (uint256 liquidity, uint256 innerFeeGrowth0Token, uint256 innerFeeGrowth1Token, uint128 fees0, uint128 fees1);\r\n\r\n  /// @notice Returns the information about active incentive\r\n  /// @dev if there is no active incentive at the moment, incentiveAddress would be equal to address(0)\r\n  /// @return incentiveAddress The address associated with the current active incentive\r\n  function activeIncentive() external view returns (address incentiveAddress);\r\n}\r\n"
    },
    "@alkaswap/core/contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\nlibrary Constants {\r\n  uint8 internal constant RESOLUTION = 96;\r\n  uint256 internal constant Q32 = 1 << 32;\r\n  uint256 internal constant Q48 = 1 << 48;\r\n  uint256 internal constant Q64 = 1 << 64;\r\n  uint256 internal constant Q96 = 1 << 96;\r\n  uint256 internal constant Q128 = 1 << 128;\r\n  uint256 internal constant Q144 = 1 << 144;\r\n  int256 internal constant Q160 = 1 << 160;\r\n\r\n  uint16 internal constant BASE_FEE = 0.0001e6; // init minimum fee value in hundredths of a bip (0.01%)\r\n  uint24 internal constant FEE_DENOMINATOR = 1e6;\r\n  int24 internal constant INIT_TICK_SPACING = 60;\r\n  int24 internal constant MAX_TICK_SPACING = 500;\r\n\r\n  // Defines the maximum and minimum ticks allowed for limit orders. Corresponds to the range of possible\r\n  // price values ​​in UniswapV2. Due to this limitation, sufficient accuracy is achieved even with the minimum allowable tick\r\n  int24 constant MAX_LIMIT_ORDER_TICK = 776363;\r\n\r\n  // the frequency with which the accumulated community fees are sent to the vault\r\n  uint32 internal constant COMMUNITY_FEE_TRANSFER_FREQUENCY = 8 hours;\r\n\r\n  // max(uint128) / ( (MAX_TICK - MIN_TICK) )\r\n  uint128 internal constant MAX_LIQUIDITY_PER_TICK = 40564824043007195767232224305152;\r\n\r\n  uint8 internal constant MAX_COMMUNITY_FEE = 0.25e3; // 25%\r\n  uint256 internal constant COMMUNITY_FEE_DENOMINATOR = 1e3;\r\n  // role that can change communityFee and tickspacing in pools\r\n  bytes32 internal constant POOLS_ADMINISTRATOR_ROLE = keccak256('POOLS_ADMINISTRATOR');\r\n}\r\n"
    },
    "@alkaswap/core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n  /// @param a The multiplicand\r\n  /// @param b The multiplier\r\n  /// @param denominator The divisor\r\n  /// @return result The 256-bit result\r\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n  function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\r\n    unchecked {\r\n      // 512-bit multiply [prod1 prod0] = a * b\r\n      // Compute the product mod 2**256 and mod 2**256 - 1\r\n      // then use the Chinese Remainder Theorem to reconstruct\r\n      // the 512 bit result. The result is stored in two 256\r\n      // variables such that product = prod1 * 2**256 + prod0\r\n      uint256 prod0 = a * b; // Least significant 256 bits of the product\r\n      uint256 prod1; // Most significant 256 bits of the product\r\n      assembly {\r\n        let mm := mulmod(a, b, not(0))\r\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n      }\r\n\r\n      // Make sure the result is less than 2**256.\r\n      // Also prevents denominator == 0\r\n      require(denominator > prod1);\r\n\r\n      // Handle non-overflow cases, 256 by 256 division\r\n      if (prod1 == 0) {\r\n        assembly {\r\n          result := div(prod0, denominator)\r\n        }\r\n        return result;\r\n      }\r\n\r\n      ///////////////////////////////////////////////\r\n      // 512 by 256 division.\r\n      ///////////////////////////////////////////////\r\n\r\n      // Make division exact by subtracting the remainder from [prod1 prod0]\r\n      // Compute remainder using mulmod\r\n      // Subtract 256 bit remainder from 512 bit number\r\n      assembly {\r\n        let remainder := mulmod(a, b, denominator)\r\n        prod1 := sub(prod1, gt(remainder, prod0))\r\n        prod0 := sub(prod0, remainder)\r\n      }\r\n\r\n      // Factor powers of two out of denominator\r\n      // Compute largest power of two divisor of denominator.\r\n      // Always >= 1.\r\n      uint256 twos = (0 - denominator) & denominator;\r\n      // Divide denominator by power of two\r\n      assembly {\r\n        denominator := div(denominator, twos)\r\n      }\r\n\r\n      // Divide [prod1 prod0] by the factors of two\r\n      assembly {\r\n        prod0 := div(prod0, twos)\r\n      }\r\n      // Shift in bits from prod1 into prod0. For this we need\r\n      // to flip `twos` such that it is 2**256 / twos.\r\n      // If twos is zero, then it becomes one\r\n      assembly {\r\n        twos := add(div(sub(0, twos), twos), 1)\r\n      }\r\n      prod0 |= prod1 * twos;\r\n\r\n      // Invert denominator mod 2**256\r\n      // Now that denominator is an odd number, it has an inverse\r\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n      // Compute the inverse by starting with a seed that is correct\r\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n      uint256 inv = (3 * denominator) ^ 2;\r\n      // Now use Newton-Raphson iteration to improve the precision.\r\n      // Thanks to Hensel's lifting lemma, this also works in modular\r\n      // arithmetic, doubling the correct bits in each step.\r\n      inv *= 2 - denominator * inv; // inverse mod 2**8\r\n      inv *= 2 - denominator * inv; // inverse mod 2**16\r\n      inv *= 2 - denominator * inv; // inverse mod 2**32\r\n      inv *= 2 - denominator * inv; // inverse mod 2**64\r\n      inv *= 2 - denominator * inv; // inverse mod 2**128\r\n      inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n      // Because the division is now exact we can divide by multiplying\r\n      // with the modular inverse of denominator. This will give us the\r\n      // correct result modulo 2**256. Since the preconditions guarantee\r\n      // that the outcome is less than 2**256, this is the final result.\r\n      // We don't need to compute the high bits of the result and prod1\r\n      // is no longer required.\r\n      result = prod0 * inv;\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n  /// @param a The multiplicand\r\n  /// @param b The multiplier\r\n  /// @param denominator The divisor\r\n  /// @return result The 256-bit result\r\n  function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\r\n    unchecked {\r\n      if (a == 0 || ((result = a * b) / a == b)) {\r\n        require(denominator > 0);\r\n        assembly {\r\n          result := add(div(result, denominator), gt(mod(result, denominator), 0))\r\n        }\r\n      } else {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n          require(result < type(uint256).max);\r\n          result++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Returns ceil(x / y)\r\n  /// @dev division by 0 has unspecified behavior, and must be checked externally\r\n  /// @param x The dividend\r\n  /// @param y The divisor\r\n  /// @return z The quotient, ceil(x / y)\r\n  function unsafeDivRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n    assembly {\r\n      z := add(div(x, y), gt(mod(x, y), 0))\r\n    }\r\n  }\r\n}\r\n"
    },
    "@alkaswap/core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity ^0.8.0;\r\n\r\n/// @title Optimized overflow and underflow safe math operations\r\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries\r\nlibrary LowGasSafeMath {\r\n  /// @notice Returns x + y, reverts if sum overflows uint256\r\n  /// @param x The augend\r\n  /// @param y The addend\r\n  /// @return z The sum of x and y\r\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n    unchecked {\r\n      require((z = x + y) >= x);\r\n    }\r\n  }\r\n\r\n  /// @notice Returns x - y, reverts if underflows\r\n  /// @param x The minuend\r\n  /// @param y The subtrahend\r\n  /// @return z The difference of x and y\r\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n    unchecked {\r\n      require((z = x - y) <= x);\r\n    }\r\n  }\r\n\r\n  /// @notice Returns x * y, reverts if overflows\r\n  /// @param x The multiplicand\r\n  /// @param y The multiplier\r\n  /// @return z The product of x and y\r\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n    unchecked {\r\n      require(x == 0 || (z = x * y) / x == y);\r\n    }\r\n  }\r\n\r\n  /// @notice Returns x + y, reverts if overflows or underflows\r\n  /// @param x The augend\r\n  /// @param y The addend\r\n  /// @return z The sum of x and y\r\n  function add(int256 x, int256 y) internal pure returns (int256 z) {\r\n    unchecked {\r\n      require((z = x + y) >= x == (y >= 0));\r\n    }\r\n  }\r\n\r\n  /// @notice Returns x - y, reverts if overflows or underflows\r\n  /// @param x The minuend\r\n  /// @param y The subtrahend\r\n  /// @return z The difference of x and y\r\n  function sub(int256 x, int256 y) internal pure returns (int256 z) {\r\n    unchecked {\r\n      require((z = x - y) <= x == (y >= 0));\r\n    }\r\n  }\r\n\r\n  /// @notice Returns x + y, reverts if overflows or underflows\r\n  /// @param x The augend\r\n  /// @param y The addend\r\n  /// @return z The sum of x and y\r\n  function add128(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n    unchecked {\r\n      require((z = x + y) >= x);\r\n    }\r\n  }\r\n}\r\n"
    },
    "@alkaswap/core/contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0 || ^0.8.0;\r\n\r\n/// @title Safe casting methods\r\n/// @notice Contains methods for safely casting between types\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries\r\nlibrary SafeCast {\r\n  /// @notice Cast a uint256 to a uint160, revert on overflow\r\n  /// @param y The uint256 to be downcasted\r\n  /// @return z The downcasted integer, now type uint160\r\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\r\n    require((z = uint160(y)) == y);\r\n  }\r\n\r\n  /// @notice Cast a uint256 to a uint128, revert on overflow\r\n  /// @param y The uint256 to be downcasted\r\n  /// @return z The downcasted integer, now type uint128\r\n  function toUint128(uint256 y) internal pure returns (uint128 z) {\r\n    require((z = uint128(y)) == y);\r\n  }\r\n\r\n  /// @notice Cast a int256 to a int128, revert on overflow or underflow\r\n  /// @param y The int256 to be downcasted\r\n  /// @return z The downcasted integer, now type int128\r\n  function toInt128(int256 y) internal pure returns (int128 z) {\r\n    require((z = int128(y)) == y);\r\n  }\r\n\r\n  /// @notice Cast a uint256 to a int256, revert on overflow\r\n  /// @param y The uint256 to be casted\r\n  /// @return z The casted integer, now type int256\r\n  function toInt256(uint256 y) internal pure returns (int256 z) {\r\n    require((z = int256(y)) >= 0);\r\n  }\r\n}\r\n"
    },
    "@alkaswap/core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.4 <0.9.0;\r\n\r\nimport '../interfaces/IAlgebraPoolErrors.sol';\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries\r\nlibrary TickMath {\r\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n  int24 internal constant MIN_TICK = -887272;\r\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n  int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n  /// @dev Throws if |tick| > max tick\r\n  /// @param tick The input tick for the above formula\r\n  /// @return price A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n  /// at the given tick\r\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 price) {\r\n    unchecked {\r\n      // get abs value\r\n      int24 mask = tick >> (24 - 1);\r\n      uint256 absTick = uint24((tick ^ mask) - mask);\r\n      if (absTick > uint24(MAX_TICK)) revert IAlgebraPoolErrors.tickOutOfRange();\r\n\r\n      uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n      if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n      if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n      if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n      if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n      if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n      if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n      if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n      if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n      if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n      if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n      if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n      if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n      if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n      if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n      if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n      if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n      if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n      if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n      if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n      if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n      // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n      price = uint160((ratio + 0xFFFFFFFF) >> 32);\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n  /// @dev Throws in case price < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n  /// ever return.\r\n  /// @param price The sqrt ratio for which to compute the tick as a Q64.96\r\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n  function getTickAtSqrtRatio(uint160 price) internal pure returns (int24 tick) {\r\n    unchecked {\r\n      // second inequality must be >= because the price can never reach the price at the max tick\r\n      if (price < MIN_SQRT_RATIO || price >= MAX_SQRT_RATIO) revert IAlgebraPoolErrors.priceOutOfRange();\r\n      uint256 ratio = uint256(price) << 32;\r\n\r\n      uint256 r = ratio;\r\n      uint256 msb = 0;\r\n\r\n      assembly {\r\n        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(5, gt(r, 0xFFFFFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(4, gt(r, 0xFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(3, gt(r, 0xFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(2, gt(r, 0xF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(1, gt(r, 0x3))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := gt(r, 0x1)\r\n        msb := or(msb, f)\r\n      }\r\n\r\n      if (msb >= 128) r = ratio >> (msb - 127);\r\n      else r = ratio << (127 - msb);\r\n\r\n      int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(63, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(62, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(61, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(60, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(59, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(58, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(57, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(56, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(55, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(54, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(53, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(52, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(51, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(50, f))\r\n      }\r\n\r\n      int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n      int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n      int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n      tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= price ? tickHi : tickLow;\r\n    }\r\n  }\r\n}\r\n"
    },
    "@alkaswap/core/contracts/libraries/TickTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\nimport './Constants.sol';\r\nimport './TickMath.sol';\r\n\r\n/// @title Packed tick initialized state library\r\n/// @notice Stores a packed mapping of tick index to its initialized state and search tree\r\n/// @dev The leafs mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\r\nlibrary TickTree {\r\n  int16 internal constant SECOND_LAYER_OFFSET = 3466; // ceil(MAX_TICK / 256)\r\n\r\n  /// @notice Toggles the initialized state for a given tick from false to true, or vice versa\r\n  /// @param leafs The mapping of words with ticks\r\n  /// @param secondLayer The mapping of words with leafs\r\n  /// @param tick The tick to toggle\r\n  /// @param treeRoot The word with info about active subtrees\r\n  function toggleTick(\r\n    mapping(int16 => uint256) storage leafs,\r\n    mapping(int16 => uint256) storage secondLayer,\r\n    int24 tick,\r\n    uint256 treeRoot\r\n  ) internal returns (uint256 newTreeRoot) {\r\n    newTreeRoot = treeRoot;\r\n    (bool toggledNode, int16 nodeNumber) = _toggleTickInNode(leafs, tick);\r\n    if (toggledNode) {\r\n      unchecked {\r\n        (toggledNode, nodeNumber) = _toggleTickInNode(secondLayer, nodeNumber + SECOND_LAYER_OFFSET);\r\n      }\r\n      if (toggledNode) {\r\n        assembly {\r\n          newTreeRoot := xor(newTreeRoot, shl(nodeNumber, 1))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates the required node and toggles tick in it\r\n  /// @param row The level of tree\r\n  /// @param tick The tick to toggle\r\n  /// @return toggledNode Toggled whole node or not\r\n  /// @return nodeNumber Number of corresponding node\r\n  function _toggleTickInNode(mapping(int16 => uint256) storage row, int24 tick) private returns (bool toggledNode, int16 nodeNumber) {\r\n    assembly {\r\n      nodeNumber := sar(8, tick)\r\n    }\r\n    uint256 node = row[nodeNumber];\r\n    assembly {\r\n      toggledNode := iszero(node)\r\n      node := xor(node, shl(and(tick, 0xFF), 1))\r\n      toggledNode := xor(toggledNode, iszero(node))\r\n    }\r\n    row[nodeNumber] = node;\r\n  }\r\n\r\n  /// @notice Returns the next initialized tick in tree to the right (gte) of the given tick or `MAX_TICK`\r\n  /// @param leafs The words with ticks\r\n  /// @param secondLayer The words with info about active leafs\r\n  /// @param treeRoot The word with info about active subtrees\r\n  /// @param tick The starting tick\r\n  /// @return nextTick The next initialized tick or `MAX_TICK`\r\n  function getNextTick(\r\n    mapping(int16 => uint256) storage leafs,\r\n    mapping(int16 => uint256) storage secondLayer,\r\n    uint256 treeRoot,\r\n    int24 tick\r\n  ) internal view returns (int24 nextTick) {\r\n    unchecked {\r\n      tick++;\r\n      int16 nodeNumber;\r\n      bool initialized;\r\n      assembly {\r\n        // index in treeRoot\r\n        nodeNumber := shr(8, add(sar(8, tick), SECOND_LAYER_OFFSET))\r\n      }\r\n      if (treeRoot & (1 << uint16(nodeNumber)) != 0) {\r\n        // if subtree has active ticks\r\n        // try to find initialized tick in the corresponding leaf of the tree\r\n        (nodeNumber, nextTick, initialized) = _getNextActiveBitInSameNode(leafs, tick);\r\n        if (initialized) return nextTick;\r\n\r\n        // try to find next initialized leaf in the tree\r\n        (nodeNumber, nextTick, initialized) = _getNextActiveBitInSameNode(secondLayer, nodeNumber + SECOND_LAYER_OFFSET + 1);\r\n      }\r\n      if (!initialized) {\r\n        // try to find which subtree has an active leaf\r\n        (nextTick, initialized) = _nextActiveBitInTheSameNode(treeRoot, ++nodeNumber);\r\n        if (!initialized) return TickMath.MAX_TICK;\r\n        nextTick = _getFirstActiveBitInNode(secondLayer, nextTick);\r\n      }\r\n      nextTick = _getFirstActiveBitInNode(leafs, nextTick - SECOND_LAYER_OFFSET);\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates node with given tick and returns next active tick\r\n  /// @param row level of search tree\r\n  /// @param tick The starting tick\r\n  /// @return nodeNumber Number of corresponding node\r\n  /// @return nextTick Number of next active tick or last tick in node\r\n  /// @return initialized Is nextTick initialized or not\r\n  function _getNextActiveBitInSameNode(\r\n    mapping(int16 => uint256) storage row,\r\n    int24 tick\r\n  ) private view returns (int16 nodeNumber, int24 nextTick, bool initialized) {\r\n    assembly {\r\n      nodeNumber := sar(8, tick)\r\n    }\r\n    (nextTick, initialized) = _nextActiveBitInTheSameNode(row[nodeNumber], tick);\r\n  }\r\n\r\n  /// @notice Returns first active tick in given node\r\n  /// @param row level of search tree\r\n  /// @param nodeNumber Number of corresponding node\r\n  /// @return nextTick Number of next active tick or last tick in node\r\n  function _getFirstActiveBitInNode(mapping(int16 => uint256) storage row, int24 nodeNumber) private view returns (int24 nextTick) {\r\n    assembly {\r\n      nextTick := shl(8, nodeNumber)\r\n    }\r\n    (nextTick, ) = _nextActiveBitInTheSameNode(row[int16(nodeNumber)], nextTick);\r\n  }\r\n\r\n  /// @notice Returns the next initialized tick contained in the same word as the tick that is\r\n  /// to the right or at (gte) of the given tick\r\n  /// @param word The word in which to compute the next initialized tick\r\n  /// @param tick The starting tick\r\n  /// @return nextTick The next initialized or uninitialized tick up to 256 ticks away from the current tick\r\n  /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\r\n  function _nextActiveBitInTheSameNode(uint256 word, int24 tick) private pure returns (int24 nextTick, bool initialized) {\r\n    uint256 bitNumber;\r\n    assembly {\r\n      bitNumber := and(tick, 0xFF)\r\n    }\r\n    unchecked {\r\n      uint256 _row = word >> bitNumber; // all the 1s at or to the left of the bitNumber\r\n      if (_row == 0) {\r\n        nextTick = tick + int24(uint24(255 - bitNumber));\r\n      } else {\r\n        nextTick = tick + int24(uint24(getSingleSignificantBit((0 - _row) & _row))); // least significant bit\r\n        initialized = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice get position of single 1-bit\r\n  /// @dev it is assumed that word contains exactly one 1-bit, otherwise the result will be incorrect\r\n  /// @param word The word containing only one 1-bit\r\n  function getSingleSignificantBit(uint256 word) internal pure returns (uint8 singleBitPos) {\r\n    assembly {\r\n      singleBitPos := iszero(and(word, 0x5555555555555555555555555555555555555555555555555555555555555555))\r\n      singleBitPos := or(singleBitPos, shl(7, iszero(and(word, 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))))\r\n      singleBitPos := or(singleBitPos, shl(6, iszero(and(word, 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF))))\r\n      singleBitPos := or(singleBitPos, shl(5, iszero(and(word, 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF))))\r\n      singleBitPos := or(singleBitPos, shl(4, iszero(and(word, 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF))))\r\n      singleBitPos := or(singleBitPos, shl(3, iszero(and(word, 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF))))\r\n      singleBitPos := or(singleBitPos, shl(2, iszero(and(word, 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F))))\r\n      singleBitPos := or(singleBitPos, shl(1, iszero(and(word, 0x3333333333333333333333333333333333333333333333333333333333333333))))\r\n    }\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/base/BlockTimestamp.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n/// @title Function for getting block timestamp\r\n/// @dev Base contract that is overridden for tests\r\nabstract contract BlockTimestamp {\r\n    /// @dev Method that exists purely to be overridden for tests\r\n    /// @return The current block timestamp\r\n    function _blockTimestamp() internal view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/base/ERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';\r\nimport '@openzeppelin/contracts/utils/Address.sol';\r\n\r\nimport '../libraries/ChainId.sol';\r\nimport '../interfaces/external/IERC1271.sol';\r\nimport '../interfaces/IERC721Permit.sol';\r\nimport './BlockTimestamp.sol';\r\n\r\n/// @title ERC721 with permit\r\n/// @notice Nonfungible tokens that support an approve via signature, i.e. permit\r\nabstract contract ERC721Permit is BlockTimestamp, ERC721Enumerable, IERC721Permit {\r\n    /// @dev Gets the current nonce for a token ID and then increments it, returning the original value\r\n    function _getAndIncrementNonce(uint256 tokenId) internal virtual returns (uint256);\r\n\r\n    /// @dev The hash of the name used in the permit signature verification\r\n    bytes32 private immutable nameHash;\r\n\r\n    /// @dev The hash of the version string used in the permit signature verification\r\n    bytes32 private immutable versionHash;\r\n\r\n    /// @notice Computes the nameHash and versionHash\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory version_\r\n    ) ERC721(name_, symbol_) {\r\n        nameHash = keccak256(bytes(name_));\r\n        versionHash = keccak256(bytes(version_));\r\n    }\r\n\r\n    /// @inheritdoc IERC721Permit\r\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\r\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\r\n                    nameHash,\r\n                    versionHash,\r\n                    ChainId.get(),\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @inheritdoc IERC721Permit\r\n    /// @dev Value is equal to keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH =\r\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\r\n\r\n    /// @inheritdoc IERC721Permit\r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable override {\r\n        require(_blockTimestamp() <= deadline, 'Permit expired');\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR(),\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, _getAndIncrementNonce(tokenId), deadline))\r\n            )\r\n        );\r\n        address owner = ownerOf(tokenId);\r\n        require(spender != owner, 'ERC721Permit: approval to current owner');\r\n\r\n        if (Address.isContract(owner)) {\r\n            require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, 'Unauthorized');\r\n        } else {\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(recoveredAddress != address(0), 'Invalid signature');\r\n            require(recoveredAddress == owner, 'Unauthorized');\r\n        }\r\n\r\n        _approve(spender, tokenId);\r\n    }\r\n}\r\n"
    },
    "contracts/base/LiquidityManagement.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@alkaswap/core/contracts/interfaces/callback/IAlgebraMintCallback.sol';\nimport '@alkaswap/core/contracts/libraries/TickMath.sol';\n\nimport '../libraries/PoolAddress.sol';\nimport '../libraries/CallbackValidation.sol';\nimport '../libraries/LiquidityAmounts.sol';\n\nimport '../libraries/PoolInteraction.sol';\n\nimport './PeripheryPayments.sol';\nimport './PeripheryImmutableState.sol';\n\n/// @title Liquidity management functions\n/// @notice Internal functions for safely managing liquidity in Algebra\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\nabstract contract LiquidityManagement is IAlgebraMintCallback, PeripheryImmutableState, PeripheryPayments {\n    using PoolInteraction for IAlgebraPool;\n    struct MintCallbackData {\n        PoolAddress.PoolKey poolKey;\n        address payer;\n    }\n\n    /// @inheritdoc IAlgebraMintCallback\n    function algebraMintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external override {\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        CallbackValidation.verifyCallback(poolDeployer, decoded.poolKey);\n\n        if (amount0Owed > 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);\n        if (amount1Owed > 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);\n    }\n\n    struct AddLiquidityParams {\n        address token0;\n        address token1;\n        address recipient;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    function addLiquidity(\n        AddLiquidityParams memory params\n    )\n        internal\n        returns (uint128 liquidity, uint256 actualLiquidity, uint256 amount0, uint256 amount1, IAlgebraPool pool)\n    {\n        PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({token0: params.token0, token1: params.token1});\n\n        pool = IAlgebraPool(PoolAddress.computeAddress(poolDeployer, poolKey));\n\n        // compute the liquidity amount\n        {\n            uint160 sqrtPriceX96 = pool._getSqrtPrice();\n            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);\n            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);\n\n            liquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96,\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                params.amount0Desired,\n                params.amount1Desired\n            );\n        }\n\n        (amount0, amount1, actualLiquidity) = pool.mint(\n            msg.sender,\n            params.recipient,\n            params.tickLower,\n            params.tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n        );\n\n        require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');\n    }\n\n    /// @notice Create limit order in pool\n    function createLimitOrder(\n        IAlgebraPool pool,\n        address token0,\n        address token1,\n        int24 tick,\n        uint128 amount\n    ) internal returns (bool depositedToken) {\n        PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({token0: token0, token1: token1});\n\n        (, uint256 amount1, ) = pool.mint(\n            msg.sender,\n            address(this),\n            tick,\n            tick,\n            amount,\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n        );\n        depositedToken = amount1 > 0;\n    }\n}\n"
    },
    "contracts/base/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\npragma abicoder v2;\r\n\r\nimport '../interfaces/IMulticall.sol';\r\n\r\n/// @title Multicall\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall is IMulticall {\r\n    /// @inheritdoc IMulticall\r\n    function multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\r\n                if (result.length < 68) revert();\r\n                assembly {\r\n                    result := add(result, 0x04)\r\n                }\r\n                revert(abi.decode(result, (string)));\r\n            }\r\n\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/base/PeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\nimport '../interfaces/IPeripheryImmutableState.sol';\r\n\r\n/// @title Immutable state\r\n/// @notice Immutable state used by periphery contracts\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\nabstract contract PeripheryImmutableState is IPeripheryImmutableState {\r\n    /// @inheritdoc IPeripheryImmutableState\r\n    address public immutable override factory;\r\n    /// @inheritdoc IPeripheryImmutableState\r\n    address public immutable override poolDeployer;\r\n    /// @inheritdoc IPeripheryImmutableState\r\n    address public immutable override WNativeToken;\r\n\r\n    constructor(\r\n        address _factory,\r\n        address _WNativeToken,\r\n        address _poolDeployer\r\n    ) {\r\n        factory = _factory;\r\n        poolDeployer = _poolDeployer;\r\n        WNativeToken = _WNativeToken;\r\n    }\r\n}\r\n"
    },
    "contracts/base/PeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\n\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\n\r\nimport '../interfaces/IPeripheryPayments.sol';\r\nimport '../interfaces/external/IWNativeToken.sol';\r\n\r\nimport '../libraries/TransferHelper.sol';\r\n\r\nimport './PeripheryImmutableState.sol';\r\n\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\nabstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState {\r\n    receive() external payable {\r\n        require(msg.sender == WNativeToken, 'Not WNativeToken');\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPayments\r\n    function unwrapWNativeToken(uint256 amountMinimum, address recipient) external payable override {\r\n        uint256 balanceWNativeToken = IWNativeToken(WNativeToken).balanceOf(address(this));\r\n        require(balanceWNativeToken >= amountMinimum, 'Insufficient WNativeToken');\r\n\r\n        if (balanceWNativeToken > 0) {\r\n            IWNativeToken(WNativeToken).withdraw(balanceWNativeToken);\r\n            TransferHelper.safeTransferNative(recipient, balanceWNativeToken);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPayments\r\n    function sweepToken(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient\r\n    ) external payable override {\r\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\r\n        require(balanceToken >= amountMinimum, 'Insufficient token');\r\n\r\n        if (balanceToken > 0) {\r\n            TransferHelper.safeTransfer(token, recipient, balanceToken);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPayments\r\n    function refundNativeToken() external payable override {\r\n        if (address(this).balance > 0) TransferHelper.safeTransferNative(msg.sender, address(this).balance);\r\n    }\r\n\r\n    /// @param token The token to pay\r\n    /// @param payer The entity that must pay\r\n    /// @param recipient The entity that will receive payment\r\n    /// @param value The amount to pay\r\n    function pay(\r\n        address token,\r\n        address payer,\r\n        address recipient,\r\n        uint256 value\r\n    ) internal {\r\n        if (token == WNativeToken && address(this).balance >= value) {\r\n            // pay with WNativeToken\r\n            IWNativeToken(WNativeToken).deposit{value: value}(); // wrap only what is needed to pay\r\n            IWNativeToken(WNativeToken).transfer(recipient, value);\r\n        } else if (payer == address(this)) {\r\n            // pay with tokens already in the contract (for the exact input multihop case)\r\n            TransferHelper.safeTransfer(token, recipient, value);\r\n        } else {\r\n            // pull payment\r\n            TransferHelper.safeTransferFrom(token, payer, recipient, value);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/base/PeripheryPaymentsWithFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\n\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\n\r\nimport './PeripheryPayments.sol';\r\nimport '../interfaces/IPeripheryPaymentsWithFee.sol';\r\n\r\nimport '../interfaces/external/IWNativeToken.sol';\r\nimport '../libraries/TransferHelper.sol';\r\n\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\nabstract contract PeripheryPaymentsWithFee is PeripheryPayments, IPeripheryPaymentsWithFee {\r\n    /// @inheritdoc IPeripheryPaymentsWithFee\r\n    function unwrapWNativeTokenWithFee(\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) public payable override {\r\n        require(feeBips > 0 && feeBips <= 100);\r\n\r\n        uint256 balanceWNativeToken = IWNativeToken(WNativeToken).balanceOf(address(this));\r\n        require(balanceWNativeToken >= amountMinimum, 'Insufficient WNativeToken');\r\n\r\n        if (balanceWNativeToken > 0) {\r\n            IWNativeToken(WNativeToken).withdraw(balanceWNativeToken);\r\n            uint256 feeAmount = (balanceWNativeToken * feeBips) / 10_000;\r\n            if (feeAmount > 0) TransferHelper.safeTransferNative(feeRecipient, feeAmount);\r\n            TransferHelper.safeTransferNative(recipient, balanceWNativeToken - feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPaymentsWithFee\r\n    function sweepTokenWithFee(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) public payable override {\r\n        require(feeBips > 0 && feeBips <= 100);\r\n\r\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\r\n        require(balanceToken >= amountMinimum, 'Insufficient token');\r\n\r\n        if (balanceToken > 0) {\r\n            uint256 feeAmount = (balanceToken * feeBips) / 10_000;\r\n            if (feeAmount > 0) TransferHelper.safeTransfer(token, feeRecipient, feeAmount);\r\n            TransferHelper.safeTransfer(token, recipient, balanceToken - feeAmount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/base/PeripheryValidation.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\nimport './BlockTimestamp.sol';\r\n\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\nabstract contract PeripheryValidation is BlockTimestamp {\r\n    modifier checkDeadline(uint256 deadline) {\r\n        _checkDeadline(deadline);\r\n        _;\r\n    }\r\n\r\n    function _checkDeadline(uint256 deadline) private view {\r\n        require(_blockTimestamp() <= deadline, 'Transaction too old');\r\n    }\r\n}\r\n"
    },
    "contracts/base/PoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\nimport './PeripheryImmutableState.sol';\nimport '../interfaces/IPoolInitializer.sol';\n\nimport '../libraries/PoolInteraction.sol';\n\n/// @title Creates and initializes Algebra Pools\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\nabstract contract PoolInitializer is IPoolInitializer, PeripheryImmutableState {\n    using PoolInteraction for IAlgebraPool;\n\n    /// @inheritdoc IPoolInitializer\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint160 sqrtPriceX96\n    ) external payable override returns (address pool) {\n        require(token0 < token1);\n\n        pool = IAlgebraFactory(factory).poolByPair(token0, token1);\n\n        if (pool == address(0)) {\n            pool = IAlgebraFactory(factory).createPool(token0, token1);\n\n            IAlgebraPool(pool).initialize(sqrtPriceX96);\n        } else {\n            uint160 sqrtPriceX96Existing = IAlgebraPool(pool)._getSqrtPrice();\n            if (sqrtPriceX96Existing == 0) {\n                IAlgebraPool(pool).initialize(sqrtPriceX96);\n            }\n        }\n    }\n}\n"
    },
    "contracts/base/SelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\nimport '@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol';\r\n\r\nimport '../interfaces/ISelfPermit.sol';\r\nimport '../interfaces/external/IERC20PermitAllowed.sol';\r\n\r\n/// @title Self Permit\r\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\r\n/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function\r\n/// that requires an approval in a single transaction.\r\nabstract contract SelfPermit is ISelfPermit {\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermit(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public payable override {\r\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n    }\r\n\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermitIfNecessary(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable override {\r\n        if (IERC20(token).allowance(msg.sender, address(this)) < value) selfPermit(token, value, deadline, v, r, s);\r\n    }\r\n\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermitAllowed(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public payable override {\r\n        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\r\n    }\r\n\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermitAllowedIfNecessary(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable override {\r\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\r\n            selfPermitAllowed(token, nonce, expiry, v, r, s);\r\n    }\r\n}\r\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\n"
    },
    "contracts/interfaces/external/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Interface for verifying contract-based account signatures\r\n/// @notice Interface that verifies provided signature for the data\r\n/// @dev Interface defined by EIP-1271\r\ninterface IERC1271 {\r\n    /// @notice Returns whether the provided signature is valid for the provided data\r\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\r\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\r\n    /// MUST allow external calls.\r\n    /// @param hash Hash of the data to be signed\r\n    /// @param signature Signature byte array associated with _data\r\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\r\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\r\n}\r\n"
    },
    "contracts/interfaces/external/IERC20PermitAllowed.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Interface for permit\r\n/// @notice Interface used by DAI/CHAI for permit\r\ninterface IERC20PermitAllowed {\r\n    /// @notice Approve the spender to spend some tokens via the holder signature\r\n    /// @dev This is the permit interface used by DAI and CHAI\r\n    /// @param holder The address of the token holder, the token owner\r\n    /// @param spender The address of the token spender\r\n    /// @param nonce The holder's nonce, increases at each call to permit\r\n    /// @param expiry The timestamp at which the permit is no longer valid\r\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/external/IWNativeToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\n\r\n/// @title Interface for WNativeToken\r\ninterface IWNativeToken is IERC20 {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/interfaces/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\n\r\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\r\n\r\n/// @title ERC721 with permit\r\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\r\ninterface IERC721Permit is IERC721 {\r\n    /// @notice The permit typehash used in the permit signature\r\n    /// @return The typehash for the permit\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    /// @notice The domain separator used in the permit signature\r\n    /// @return The domain separator used in encoding of permit signature\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    /// @notice Approve of a specific token ID for spending by spender via signature\r\n    /// @param spender The account that is being approved\r\n    /// @param tokenId The ID of the token that is being approved for spending\r\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n}\r\n"
    },
    "contracts/interfaces/ILimitOrderManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\r\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\r\n\r\nimport './IERC721Permit.sol';\r\nimport './IPeripheryPayments.sol';\r\nimport './IPeripheryImmutableState.sol';\r\nimport '../libraries/PoolAddress.sol';\r\n\r\ninterface ILimitOrderManager is\r\n    IPeripheryPayments,\r\n    IPeripheryImmutableState,\r\n    IERC721Metadata,\r\n    IERC721Enumerable,\r\n    IERC721Permit\r\n{\r\n    function limitPositions(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            LimitPosition memory position,\r\n            address token0,\r\n            address token1\r\n        );\r\n\r\n    struct LimitPosition {\r\n        uint96 nonce;\r\n        address operator;\r\n        uint80 poolId;\r\n        uint128 liquidity;\r\n        uint128 liquidityInit;\r\n        int24 tick;\r\n        bool depositedToken;\r\n        uint128 depositedAmount;\r\n        uint256 feeGrowthInside0LastX128;\r\n        uint256 feeGrowthInside1LastX128;\r\n        uint128 tokensOwed0;\r\n        uint128 tokensOwed1;\r\n    }\r\n\r\n    struct addLimitOrderParams {\r\n        address token0;\r\n        address token1;\r\n        bool depositedToken;\r\n        uint128 amount;\r\n        int24 tick;\r\n    }\r\n\r\n    function decreaseLimitOrder(uint256 tokenId, uint128 liquidity) external payable;\r\n\r\n    function collectLimitOrder(uint256 tokenId, address recipient)\r\n        external\r\n        payable\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function addLimitOrder(addLimitOrderParams calldata params) external payable returns (uint256 tokenId);\r\n\r\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\r\n    /// must be collected first.\r\n    /// @param tokenId The ID of the token that is being burned\r\n    function burn(uint256 tokenId) external payable;\r\n}\r\n"
    },
    "contracts/interfaces/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Multicall interface\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\ninterface IMulticall {\r\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\r\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\r\n    /// @param data The encoded function data for each of the calls to make to this contract\r\n    /// @return results The results from each of the calls passed in via data\r\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\r\n}\r\n"
    },
    "contracts/interfaces/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\r\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\r\n\r\nimport './IPoolInitializer.sol';\r\nimport './IERC721Permit.sol';\r\nimport './IPeripheryPayments.sol';\r\nimport './IPeripheryImmutableState.sol';\r\nimport '../libraries/PoolAddress.sol';\r\n\r\n/// @title Non-fungible token for positions\r\n/// @notice Wraps Algebra positions in a non-fungible token interface which allows for them to be transferred\r\n/// and authorized.\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface INonfungiblePositionManager is\r\n    IPoolInitializer,\r\n    IPeripheryPayments,\r\n    IPeripheryImmutableState,\r\n    IERC721Metadata,\r\n    IERC721Enumerable,\r\n    IERC721Permit\r\n{\r\n    /// @notice Emitted when liquidity is increased for a position NFT\r\n    /// @dev Also emitted when a token is minted\r\n    /// @param tokenId The ID of the token for which liquidity was increased\r\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\r\n    /// @param actualLiquidity the actual liquidity that was added into a pool. Could differ from\r\n    /// _liquidity_ when using FeeOnTransfer tokens\r\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\r\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\r\n    event IncreaseLiquidity(\r\n        uint256 indexed tokenId,\r\n        uint128 liquidity,\r\n        uint128 actualLiquidity,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address pool\r\n    );\r\n\r\n    /// @notice Emitted when liquidity is decreased for a position NFT\r\n    /// @param tokenId The ID of the token for which liquidity was decreased\r\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\r\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\r\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\r\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Emitted when tokens are collected for a position NFT\r\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\r\n    /// @param tokenId The ID of the token for which underlying tokens were collected\r\n    /// @param recipient The address of the account that received the collected tokens\r\n    /// @param amount0 The amount of token0 owed to the position that was collected\r\n    /// @param amount1 The amount of token1 owed to the position that was collected\r\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Emitted if farming failed in call from NonfungiblePositionManager.\r\n    /// @dev Should never be emitted\r\n    /// @param tokenId The ID of corresponding token\r\n    event FarmingFailed(uint256 indexed tokenId);\r\n\r\n    /// @notice Returns the position information associated with a given token ID.\r\n    /// @dev Throws if the token ID is not valid.\r\n    /// @param tokenId The ID of the token that represents the position\r\n    /// @return nonce The nonce for permits\r\n    /// @return operator The address that is approved for spending\r\n    /// @return token0 The address of the token0 for a specific pool\r\n    /// @return token1 The address of the token1 for a specific pool\r\n    /// @return tickLower The lower end of the tick range for the position\r\n    /// @return tickUpper The higher end of the tick range for the position\r\n    /// @return liquidity The liquidity of the position\r\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\r\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\r\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\r\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\r\n    function positions(\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint88 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Creates a new position wrapped in a NFT\r\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\r\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\r\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\r\n    /// @return tokenId The ID of the token that represents the minted position\r\n    /// @return liquidity The amount of liquidity for this position\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function mint(\r\n        MintParams calldata params\r\n    ) external payable returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\r\n\r\n    struct IncreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\r\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\r\n    /// amount0Desired The desired amount of token0 to be spent,\r\n    /// amount1Desired The desired amount of token1 to be spent,\r\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\r\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\r\n    /// deadline The time by which the transaction must be included to effect the change\r\n    /// @return liquidity The new liquidity amount as a result of the increase\r\n    /// @return amount0 The amount of token0 to achieve resulting liquidity\r\n    /// @return amount1 The amount of token1 to achieve resulting liquidity\r\n    function increaseLiquidity(\r\n        IncreaseLiquidityParams calldata params\r\n    ) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\r\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\r\n    /// amount The amount by which liquidity will be decreased,\r\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\r\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\r\n    /// deadline The time by which the transaction must be included to effect the change\r\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\r\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\r\n    function decreaseLiquidity(\r\n        DecreaseLiquidityParams calldata params\r\n    ) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\r\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\r\n    /// recipient The account that should receive the tokens,\r\n    /// amount0Max The maximum amount of token0 to collect,\r\n    /// amount1Max The maximum amount of token1 to collect\r\n    /// @return amount0 The amount of fees collected in token0\r\n    /// @return amount1 The amount of fees collected in token1\r\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\r\n    /// must be collected first.\r\n    /// @param tokenId The ID of the token that is being burned\r\n    function burn(uint256 tokenId) external payable;\r\n\r\n    /// @notice Changes approval of token ID for farming.\r\n    /// @param tokenId The ID of the token that is being approved / unapproved\r\n    /// @param approve New status of approval\r\n    function approveForFarming(uint256 tokenId, bool approve) external payable;\r\n\r\n    /// @notice Changes farming status of token to 'farmed' or 'not farmed'\r\n    /// @dev can be called only by farmingCenter\r\n    /// @param tokenId tokenId The ID of the token\r\n    /// @param tokenId isFarmed The new status\r\n    function switchFarmingStatus(uint256 tokenId, bool isFarmed) external;\r\n\r\n    /// @notice Changes address of farmingCenter\r\n    /// @dev can be called only by factory owner or NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE\r\n    /// @param newFarmingCenter The new address of farmingCenter\r\n    function setFarmingCenter(address newFarmingCenter) external;\r\n}\r\n"
    },
    "contracts/interfaces/INonfungibleTokenPositionDescriptor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\nimport './INonfungiblePositionManager.sol';\r\n\r\n/// @title Describes position NFT tokens via URI\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface INonfungibleTokenPositionDescriptor {\r\n    /// @notice Produces the URI describing a particular token ID for a position manager\r\n    /// @dev Note this URI may be a data: URI with the JSON contents directly inlined\r\n    /// @param positionManager The position manager for which to describe the token\r\n    /// @param tokenId The ID of the token for which to produce a description, which may not be valid\r\n    /// @return The URI of the ERC721-compliant metadata\r\n    function tokenURI(INonfungiblePositionManager positionManager, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (string memory);\r\n}\r\n"
    },
    "contracts/interfaces/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Immutable state\r\n/// @notice Functions that return immutable state of the router\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface IPeripheryImmutableState {\r\n    /// @return Returns the address of the Algebra factory\r\n    function factory() external view returns (address);\r\n\r\n    /// @return Returns the address of the pool Deployer\r\n    function poolDeployer() external view returns (address);\r\n\r\n    /// @return Returns the address of WNativeToken\r\n    function WNativeToken() external view returns (address);\r\n}\r\n"
    },
    "contracts/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\n\r\n/// @title Periphery Payments\r\n/// @notice Functions to ease deposits and withdrawals of NativeToken\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface IPeripheryPayments {\r\n    /// @notice Unwraps the contract's WNativeToken balance and sends it to recipient as NativeToken.\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WNativeToken from users.\r\n    /// @param amountMinimum The minimum amount of WNativeToken to unwrap\r\n    /// @param recipient The address receiving NativeToken\r\n    function unwrapWNativeToken(uint256 amountMinimum, address recipient) external payable;\r\n\r\n    /// @notice Refunds any NativeToken balance held by this contract to the `msg.sender`\r\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\r\n    /// that use ether for the input amount\r\n    function refundNativeToken() external payable;\r\n\r\n    /// @notice Transfers the full amount of a token held by this contract to recipient\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\r\n    /// @param token The contract address of the token which will be transferred to `recipient`\r\n    /// @param amountMinimum The minimum amount of token required for a transfer\r\n    /// @param recipient The destination address of the token\r\n    function sweepToken(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient\r\n    ) external payable;\r\n}\r\n"
    },
    "contracts/interfaces/IPeripheryPaymentsWithFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\n\r\nimport './IPeripheryPayments.sol';\r\n\r\n/// @title Periphery Payments\r\n/// @notice Functions to ease deposits and withdrawals of NativeToken\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface IPeripheryPaymentsWithFee is IPeripheryPayments {\r\n    /// @notice Unwraps the contract's WNativeToken balance and sends it to recipient as NativeToken, with a percentage between\r\n    /// 0 (exclusive), and 1 (inclusive) going to feeRecipient\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WNativeToken from users.\r\n    function unwrapWNativeTokenWithFee(\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) external payable;\r\n\r\n    /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between\r\n    /// 0 (exclusive) and 1 (inclusive) going to feeRecipient\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\r\n    function sweepTokenWithFee(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) external payable;\r\n}\r\n"
    },
    "contracts/interfaces/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Creates and initializes Algebra Pools\r\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\r\n/// require the pool to exist.\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface IPoolInitializer {\r\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\r\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\r\n    /// @param token0 The contract address of token0 of the pool\r\n    /// @param token1 The contract address of token1 of the pool\r\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\r\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\r\n    function createAndInitializePoolIfNecessary(\r\n        address token0,\r\n        address token1,\r\n        uint160 sqrtPriceX96\r\n    ) external payable returns (address pool);\r\n}\r\n"
    },
    "contracts/interfaces/IPositionFollower.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Contract tracking liquidity position\r\n/// @notice Using these methods farmingCenter receives information about changes in the positions\r\ninterface IPositionFollower {\r\n    /// @notice Report a change of liquidity in position\r\n    /// @param tokenId The ID of the token for which liquidity is being added\r\n    /// @param liquidityDelta The amount of added liquidity\r\n    function applyLiquidityDelta(uint256 tokenId, int256 liquidityDelta) external;\r\n\r\n    /// @notice Report a burn of position token\r\n    /// @param tokenId The ID of the token which is being burned\r\n    function burnPosition(uint256 tokenId) external returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Quoter Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\n/// Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface IQuoter {\r\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair\r\n    /// @param amountIn The amount of the first token to swap\r\n    /// @return amountOut The amount of the last token that would be received\r\n    function quoteExactInput(bytes memory path, uint256 amountIn)\r\n        external\r\n        returns (uint256 amountOut, uint16[] memory fees);\r\n\r\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param amountIn The desired input amount\r\n    /// @param limitSqrtPrice The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountOut The amount of `tokenOut` that would be received\r\n    function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint160 limitSqrtPrice\r\n    ) external returns (uint256 amountOut, uint16 fee);\r\n\r\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair. Path must be provided in reverse order\r\n    /// @param amountOut The amount of the last token to receive\r\n    /// @return amountIn The amount of first token required to be paid\r\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\r\n        external\r\n        returns (uint256 amountIn, uint16[] memory fees);\r\n\r\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param amountOut The desired output amount\r\n    /// @param limitSqrtPrice The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\r\n    function quoteExactOutputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        uint160 limitSqrtPrice\r\n    ) external returns (uint256 amountIn, uint16 fee);\r\n}\r\n"
    },
    "contracts/interfaces/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title QuoterV2 Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\r\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\n/// Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface IQuoterV2 {\r\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair\r\n    /// @param amountIn The amount of the first token to swap\r\n    /// @return amountOut The amount of the last token that would be received\r\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\r\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\r\n    /// @return gasEstimate The estimate of the gas that the swap consumes\r\n    function quoteExactInput(bytes memory path, uint256 amountIn)\r\n        external\r\n        returns (\r\n            uint256 amountOut,\r\n            uint160[] memory sqrtPriceX96AfterList,\r\n            uint32[] memory initializedTicksCrossedList,\r\n            uint256 gasEstimate\r\n        );\r\n\r\n    struct QuoteExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amountIn;\r\n        uint160 limitSqrtPrice;\r\n    }\r\n\r\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\r\n    /// tokenIn The token being swapped in\r\n    /// tokenOut The token being swapped out\r\n    /// amountIn The desired input amount\r\n    /// limitSqrtPrice The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountOut The amount of `tokenOut` that would be received\r\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\r\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\r\n    /// @return gasEstimate The estimate of the gas that the swap consumes\r\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\r\n        external\r\n        returns (\r\n            uint256 amountOut,\r\n            uint160 sqrtPriceX96After,\r\n            uint32 initializedTicksCrossed,\r\n            uint256 gasEstimate\r\n        );\r\n\r\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair. Path must be provided in reverse order\r\n    /// @param amountOut The amount of the last token to receive\r\n    /// @return amountIn The amount of first token required to be paid\r\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\r\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\r\n    /// @return gasEstimate The estimate of the gas that the swap consumes\r\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\r\n        external\r\n        returns (\r\n            uint256 amountIn,\r\n            uint160[] memory sqrtPriceX96AfterList,\r\n            uint32[] memory initializedTicksCrossedList,\r\n            uint256 gasEstimate\r\n        );\r\n\r\n    struct QuoteExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amount;\r\n        uint160 limitSqrtPrice;\r\n    }\r\n\r\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\r\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\r\n    /// tokenIn The token being swapped in\r\n    /// tokenOut The token being swapped out\r\n    /// amountOut The desired output amount\r\n    /// limitSqrtPrice The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\r\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\r\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\r\n    /// @return gasEstimate The estimate of the gas that the swap consumes\r\n    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\r\n        external\r\n        returns (\r\n            uint256 amountIn,\r\n            uint160 sqrtPriceX96After,\r\n            uint32 initializedTicksCrossed,\r\n            uint256 gasEstimate\r\n        );\r\n}\r\n"
    },
    "contracts/interfaces/ISelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\n\r\n/// @title Self Permit\r\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\r\ninterface ISelfPermit {\r\n    /// @notice Permits this contract to spend a given token from `msg.sender`\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\r\n    /// @param token The address of the token spent\r\n    /// @param value The amount that can be spent of token\r\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermit(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n\r\n    /// @notice Permits this contract to spend a given token from `msg.sender`\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\r\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\r\n    /// @param token The address of the token spent\r\n    /// @param value The amount that can be spent of token\r\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermitIfNecessary(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n\r\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\r\n    /// @param token The address of the token spent\r\n    /// @param nonce The current nonce of the owner\r\n    /// @param expiry The timestamp at which the permit is no longer valid\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermitAllowed(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n\r\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\r\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\r\n    /// @param token The address of the token spent\r\n    /// @param nonce The current nonce of the owner\r\n    /// @param expiry The timestamp at which the permit is no longer valid\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermitAllowedIfNecessary(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n}\r\n"
    },
    "contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/interfaces/callback/IAlgebraSwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Algebra\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ninterface ISwapRouter is IAlgebraSwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 limitSqrtPrice;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 limitSqrtPrice;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @dev Unlike standard swaps, handles transferring from user before the actual swap.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingleSupportingFeeOnTransferTokens(\n        ExactInputSingleParams calldata params\n    ) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/ITickLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Tick Lens\r\n/// @notice Provides functions for fetching chunks of tick data for a pool\r\n/// @dev This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and\r\n/// then sending additional multicalls to fetch the tick data\r\n/// Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface ITickLens {\r\n    struct PopulatedTick {\r\n        int24 tick;\r\n        int128 liquidityNet;\r\n        uint128 liquidityGross;\r\n    }\r\n\r\n    /// @notice Get all the tick data for the populated ticks from a word of the tick bitmap of a pool\r\n    /// @param pool The address of the pool for which to fetch populated tick data\r\n    /// @param tickTableIndex The index of the word in the tick bitmap for which to parse the bitmap and\r\n    /// fetch all the populated ticks\r\n    /// @return populatedTicks An array of tick data for the given word in the tick bitmap\r\n    function getPopulatedTicksInWord(address pool, int16 tickTableIndex)\r\n        external\r\n        view\r\n        returns (PopulatedTick[] memory populatedTicks);\r\n}\r\n"
    },
    "contracts/interfaces/IV3Migrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport './IMulticall.sol';\r\nimport './ISelfPermit.sol';\r\nimport './IPoolInitializer.sol';\r\n\r\n/// @title Algebra Migrator\r\n/// @notice Enables migration of liquidity from Uniswap v2-compatible pairs into Algebra pools\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\ninterface IV3Migrator is IMulticall, ISelfPermit, IPoolInitializer {\r\n    struct MigrateParams {\r\n        address pair; // the Uniswap v2-compatible pair\r\n        uint256 liquidityToMigrate; // expected to be balanceOf(msg.sender)\r\n        uint8 percentageToMigrate; // represented as a numerator over 100\r\n        address token0;\r\n        address token1;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Min; // must be discounted by percentageToMigrate\r\n        uint256 amount1Min; // must be discounted by percentageToMigrate\r\n        address recipient;\r\n        uint256 deadline;\r\n        bool refundAsNative;\r\n    }\r\n\r\n    /// @notice Migrates liquidity to Algebra by burning v2 liquidity and minting a new position for Algebra\r\n    /// @dev Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of\r\n    /// the maximum amount of Algebra liquidity that the v2 liquidity can get. For the special case of migrating to an\r\n    /// out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range\r\n    /// @param params The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata\r\n    function migrate(MigrateParams calldata params) external;\r\n}\r\n"
    },
    "contracts/lens/Quoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/libraries/SafeCast.sol';\nimport '@alkaswap/core/contracts/libraries/TickMath.sol';\n\nimport '@alkaswap/core/contracts/libraries/FullMath.sol';\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@alkaswap/core/contracts/interfaces/callback/IAlgebraSwapCallback.sol';\n\nimport '../interfaces/IQuoter.sol';\nimport '../base/PeripheryImmutableState.sol';\nimport '../libraries/Path.sol';\nimport '../libraries/PoolAddress.sol';\nimport '../libraries/CallbackValidation.sol';\n\n/// @title Provides quotes for swaps\n/// @notice Allows getting the expected amount out or amount in for a given swap without executing the swap\n/// @dev These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute\n/// the swap and check the amounts in the callback.\n/// Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ncontract Quoter is IQuoter, IAlgebraSwapCallback, PeripheryImmutableState {\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    /// @dev Transient storage variable used to check a safety condition in exact output swaps.\n    uint256 private amountOutCached;\n\n    constructor(\n        address _factory,\n        address _WNativeToken,\n        address _poolDeployer\n    ) PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer) {}\n\n    function getPool(address tokenA, address tokenB) private view returns (IAlgebraPool) {\n        return IAlgebraPool(PoolAddress.computeAddress(poolDeployer, PoolAddress.getPoolKey(tokenA, tokenB)));\n    }\n\n    /// @inheritdoc IAlgebraSwapCallback\n    function algebraSwapCallback(int256 amount0Delta, int256 amount1Delta, bytes memory path) external view override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        (address tokenIn, address tokenOut) = path.decodeFirstPool();\n        CallbackValidation.verifyCallback(poolDeployer, tokenIn, tokenOut);\n\n        (bool isExactInput, uint256 amountToPay, uint256 amountReceived) = amount0Delta > 0\n            ? (tokenIn < tokenOut, uint256(amount0Delta), uint256(-amount1Delta))\n            : (tokenOut < tokenIn, uint256(amount1Delta), uint256(-amount0Delta));\n\n        IAlgebraPool pool = getPool(tokenIn, tokenOut);\n        (, , , uint16 fee, , , ) = pool.globalState();\n\n        if (isExactInput) {\n            assembly {\n                let ptr := mload(0x40)\n                mstore(ptr, amountReceived)\n                mstore(add(ptr, 0x20), fee)\n                revert(ptr, 64)\n            }\n        } else {\n            // if the cache has been populated, ensure that the full output amount has been received\n            if (amountOutCached != 0) require(amountReceived == amountOutCached);\n            assembly {\n                let ptr := mload(0x40)\n                mstore(ptr, amountToPay)\n                mstore(add(ptr, 0x20), fee)\n                revert(ptr, 64)\n            }\n        }\n    }\n\n    /// @dev Parses a revert reason that should contain the numeric quote\n    function parseRevertReason(bytes memory reason) private pure returns (uint256, uint16) {\n        if (reason.length != 64) {\n            if (reason.length < 68) revert('Unexpected error');\n            assembly {\n                reason := add(reason, 0x04)\n            }\n            revert(abi.decode(reason, (string)));\n        }\n        return abi.decode(reason, (uint256, uint16));\n    }\n\n    /// @inheritdoc IQuoter\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint160 limitSqrtPrice\n    ) public override returns (uint256 amountOut, uint16 fee) {\n        bool zeroToOne = tokenIn < tokenOut;\n\n        try\n            getPool(tokenIn, tokenOut).swap(\n                address(this), // address(0) might cause issues with some tokens\n                zeroToOne,\n                amountIn.toInt256(),\n                limitSqrtPrice == 0\n                    ? (zeroToOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : limitSqrtPrice,\n                abi.encodePacked(tokenIn, tokenOut)\n            )\n        {} catch (bytes memory reason) {\n            (amountOut, fee) = parseRevertReason(reason);\n        }\n    }\n\n    /// @inheritdoc IQuoter\n    function quoteExactInput(\n        bytes memory path,\n        uint256 amountIn\n    ) external override returns (uint256 amountOut, uint16[] memory fees) {\n        fees = new uint16[](path.numPools());\n        uint256 i = 0;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n\n            (address tokenIn, address tokenOut) = path.decodeFirstPool();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            (amountIn, fees[i]) = quoteExactInputSingle(tokenIn, tokenOut, amountIn, 0);\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                path = path.skipToken();\n            } else {\n                return (amountIn, fees);\n            }\n            i++;\n        }\n    }\n\n    /// @inheritdoc IQuoter\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint160 limitSqrtPrice\n    ) public override returns (uint256 amountIn, uint16 fee) {\n        bool zeroToOne = tokenIn < tokenOut;\n\n        // if no price limit has been specified, cache the output amount for comparison in the swap callback\n        if (limitSqrtPrice == 0) amountOutCached = amountOut;\n        try\n            getPool(tokenIn, tokenOut).swap(\n                address(this), // address(0) might cause issues with some tokens\n                zeroToOne,\n                -amountOut.toInt256(),\n                limitSqrtPrice == 0\n                    ? (zeroToOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : limitSqrtPrice,\n                abi.encodePacked(tokenOut, tokenIn)\n            )\n        {} catch (bytes memory reason) {\n            if (limitSqrtPrice == 0) delete amountOutCached; // clear cache\n            (amountIn, fee) = parseRevertReason(reason);\n        }\n    }\n\n    /// @inheritdoc IQuoter\n    function quoteExactOutput(\n        bytes memory path,\n        uint256 amountOut\n    ) external override returns (uint256 amountIn, uint16[] memory fees) {\n        fees = new uint16[](path.numPools());\n        uint256 i = 0;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n\n            (address tokenOut, address tokenIn) = path.decodeFirstPool();\n\n            // the inputs of prior swaps become the outputs of subsequent ones\n            (amountOut, fees[i]) = quoteExactOutputSingle(tokenIn, tokenOut, amountOut, 0);\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                path = path.skipToken();\n            } else {\n                return (amountOut, fees);\n            }\n            i++;\n        }\n    }\n}\n"
    },
    "contracts/lens/QuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/libraries/SafeCast.sol';\nimport '@alkaswap/core/contracts/libraries/TickMath.sol';\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@alkaswap/core/contracts/interfaces/callback/IAlgebraSwapCallback.sol';\n\nimport '../interfaces/IQuoterV2.sol';\nimport '../base/PeripheryImmutableState.sol';\nimport '../libraries/Path.sol';\nimport '../libraries/PoolAddress.sol';\nimport '../libraries/CallbackValidation.sol';\nimport '../libraries/PoolTicksCounter.sol';\n\n/// @title Provides quotes for swaps\n/// @notice Allows getting the expected amount out or amount in for a given swap without executing the swap\n/// @dev These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute\n/// the swap and check the amounts in the callback.\n/// Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ncontract QuoterV2 is IQuoterV2, IAlgebraSwapCallback, PeripheryImmutableState {\n    using Path for bytes;\n    using SafeCast for uint256;\n    using PoolTicksCounter for IAlgebraPool;\n\n    /// @dev Transient storage variable used to check a safety condition in exact output swaps.\n    uint256 private amountOutCached;\n\n    constructor(\n        address _factory,\n        address _WNativeToken,\n        address _poolDeployer\n    ) PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer) {}\n\n    function getPool(address tokenA, address tokenB) private view returns (IAlgebraPool) {\n        return IAlgebraPool(PoolAddress.computeAddress(poolDeployer, PoolAddress.getPoolKey(tokenA, tokenB)));\n    }\n\n    /// @inheritdoc IAlgebraSwapCallback\n    function algebraSwapCallback(int256 amount0Delta, int256 amount1Delta, bytes memory path) external view override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        (address tokenIn, address tokenOut) = path.decodeFirstPool();\n        CallbackValidation.verifyCallback(poolDeployer, tokenIn, tokenOut);\n\n        (bool isExactInput, uint256 amountToPay, uint256 amountReceived) = amount0Delta > 0\n            ? (tokenIn < tokenOut, uint256(amount0Delta), uint256(-amount1Delta))\n            : (tokenOut < tokenIn, uint256(amount1Delta), uint256(-amount0Delta));\n\n        IAlgebraPool pool = getPool(tokenIn, tokenOut);\n        (uint160 sqrtPriceX96After, int24 tickAfter, , , , , ) = pool.globalState();\n\n        if (isExactInput) {\n            assembly {\n                let ptr := mload(0x40)\n                mstore(ptr, amountReceived)\n                mstore(add(ptr, 0x20), sqrtPriceX96After)\n                mstore(add(ptr, 0x40), tickAfter)\n                revert(ptr, 96)\n            }\n        } else {\n            // if the cache has been populated, ensure that the full output amount has been received\n            if (amountOutCached != 0) require(amountReceived == amountOutCached);\n            assembly {\n                let ptr := mload(0x40)\n                mstore(ptr, amountToPay)\n                mstore(add(ptr, 0x20), sqrtPriceX96After)\n                mstore(add(ptr, 0x40), tickAfter)\n                revert(ptr, 96)\n            }\n        }\n    }\n\n    /// @dev Parses a revert reason that should contain the numeric quote\n    function parseRevertReason(\n        bytes memory reason\n    ) private pure returns (uint256 amount, uint160 sqrtPriceX96After, int24 tickAfter) {\n        if (reason.length != 96) {\n            if (reason.length < 68) revert('Unexpected error');\n            assembly {\n                reason := add(reason, 0x04)\n            }\n            revert(abi.decode(reason, (string)));\n        }\n        return abi.decode(reason, (uint256, uint160, int24));\n    }\n\n    function handleRevert(\n        bytes memory reason,\n        IAlgebraPool pool,\n        uint256 gasEstimate\n    ) private view returns (uint256 amount, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256) {\n        int24 tickBefore;\n        int24 tickAfter;\n        (, tickBefore, , , , , ) = pool.globalState();\n        (amount, sqrtPriceX96After, tickAfter) = parseRevertReason(reason);\n\n        initializedTicksCrossed = pool.countInitializedTicksCrossed(tickBefore, tickAfter);\n\n        return (amount, sqrtPriceX96After, initializedTicksCrossed, gasEstimate);\n    }\n\n    function quoteExactInputSingle(\n        QuoteExactInputSingleParams memory params\n    )\n        public\n        override\n        returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)\n    {\n        bool zeroToOne = params.tokenIn < params.tokenOut;\n        IAlgebraPool pool = getPool(params.tokenIn, params.tokenOut);\n\n        uint256 gasBefore = gasleft();\n        try\n            pool.swap(\n                address(this), // address(0) might cause issues with some tokens\n                zeroToOne,\n                params.amountIn.toInt256(),\n                params.limitSqrtPrice == 0\n                    ? (zeroToOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : params.limitSqrtPrice,\n                abi.encodePacked(params.tokenIn, params.tokenOut)\n            )\n        {} catch (bytes memory reason) {\n            gasEstimate = gasBefore - gasleft();\n            return handleRevert(reason, pool, gasEstimate);\n        }\n    }\n\n    function quoteExactInput(\n        bytes memory path,\n        uint256 amountIn\n    )\n        public\n        override\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        )\n    {\n        sqrtPriceX96AfterList = new uint160[](path.numPools());\n        initializedTicksCrossedList = new uint32[](path.numPools());\n\n        uint256 i = 0;\n        while (true) {\n            (address tokenIn, address tokenOut) = path.decodeFirstPool();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            (\n                uint256 _amountOut,\n                uint160 _sqrtPriceX96After,\n                uint32 _initializedTicksCrossed,\n                uint256 _gasEstimate\n            ) = quoteExactInputSingle(\n                    QuoteExactInputSingleParams({\n                        tokenIn: tokenIn,\n                        tokenOut: tokenOut,\n                        amountIn: amountIn,\n                        limitSqrtPrice: 0\n                    })\n                );\n\n            sqrtPriceX96AfterList[i] = _sqrtPriceX96After;\n            initializedTicksCrossedList[i] = _initializedTicksCrossed;\n            amountIn = _amountOut;\n            gasEstimate += _gasEstimate;\n            i++;\n\n            // decide whether to continue or terminate\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n            } else {\n                return (amountIn, sqrtPriceX96AfterList, initializedTicksCrossedList, gasEstimate);\n            }\n        }\n    }\n\n    function quoteExactOutputSingle(\n        QuoteExactOutputSingleParams memory params\n    )\n        public\n        override\n        returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)\n    {\n        bool zeroToOne = params.tokenIn < params.tokenOut;\n        IAlgebraPool pool = getPool(params.tokenIn, params.tokenOut);\n\n        // if no price limit has been specified, cache the output amount for comparison in the swap callback\n        if (params.limitSqrtPrice == 0) amountOutCached = params.amount;\n        uint256 gasBefore = gasleft();\n        try\n            pool.swap(\n                address(this), // address(0) might cause issues with some tokens\n                zeroToOne,\n                -params.amount.toInt256(),\n                params.limitSqrtPrice == 0\n                    ? (zeroToOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : params.limitSqrtPrice,\n                abi.encodePacked(params.tokenOut, params.tokenIn)\n            )\n        {} catch (bytes memory reason) {\n            gasEstimate = gasBefore - gasleft();\n            if (params.limitSqrtPrice == 0) delete amountOutCached; // clear cache\n            return handleRevert(reason, pool, gasEstimate);\n        }\n    }\n\n    function quoteExactOutput(\n        bytes memory path,\n        uint256 amountOut\n    )\n        public\n        override\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        )\n    {\n        sqrtPriceX96AfterList = new uint160[](path.numPools());\n        initializedTicksCrossedList = new uint32[](path.numPools());\n\n        uint256 i = 0;\n        while (true) {\n            (address tokenOut, address tokenIn) = path.decodeFirstPool();\n\n            // the inputs of prior swaps become the outputs of subsequent ones\n            (\n                uint256 _amountIn,\n                uint160 _sqrtPriceX96After,\n                uint32 _initializedTicksCrossed,\n                uint256 _gasEstimate\n            ) = quoteExactOutputSingle(\n                    QuoteExactOutputSingleParams({\n                        tokenIn: tokenIn,\n                        tokenOut: tokenOut,\n                        amount: amountOut,\n                        limitSqrtPrice: 0\n                    })\n                );\n\n            sqrtPriceX96AfterList[i] = _sqrtPriceX96After;\n            initializedTicksCrossedList[i] = _initializedTicksCrossed;\n            amountOut = _amountIn;\n            gasEstimate += _gasEstimate;\n            i++;\n\n            // decide whether to continue or terminate\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n            } else {\n                return (amountOut, sqrtPriceX96AfterList, initializedTicksCrossedList, gasEstimate);\n            }\n        }\n    }\n}\n"
    },
    "contracts/lens/TickLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\n\nimport '../interfaces/ITickLens.sol';\n\n/// @title Tick Lens contract\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ncontract TickLens is ITickLens {\n    /// @inheritdoc ITickLens\n    function getPopulatedTicksInWord(\n        address pool,\n        int16 tickTableIndex\n    ) public view override returns (PopulatedTick[] memory populatedTicks) {\n        // fetch bitmap\n        uint256 bitmap = IAlgebraPool(pool).tickTable(tickTableIndex);\n        unchecked {\n            // calculate the number of populated ticks\n            uint256 numberOfPopulatedTicks;\n            for (uint256 i = 0; i < 256; i++) {\n                if (bitmap & (1 << i) > 0) numberOfPopulatedTicks++;\n            }\n\n            // fetch populated tick data\n            populatedTicks = new PopulatedTick[](numberOfPopulatedTicks);\n            for (uint256 i = 0; i < 256; i++) {\n                if (bitmap & (1 << i) > 0) {\n                    int24 populatedTick = ((int24(tickTableIndex) << 8) + int24(uint24(i)));\n                    (uint128 liquidityGross, int128 liquidityNet, , , , , , , ) = IAlgebraPool(pool).ticks(\n                        populatedTick\n                    );\n                    populatedTicks[--numberOfPopulatedTicks] = PopulatedTick({\n                        tick: populatedTick,\n                        liquidityNet: liquidityNet,\n                        liquidityGross: liquidityGross\n                    });\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\n/**\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nlibrary BytesLib {\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, 'slice_overflow');\r\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\r\n        require(_start + 3 >= _start, 'toUint24_overflow');\r\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/CallbackValidation.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\nimport './PoolAddress.sol';\n\n/// @notice Provides validation for callbacks from Algebra Pools\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\nlibrary CallbackValidation {\n    /// @notice Returns the address of a valid Algebra Pool\n    /// @param poolDeployer The contract address of the Algebra pool deployer\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @return pool The Algebra pool contract address\n    function verifyCallback(\n        address poolDeployer,\n        address tokenA,\n        address tokenB\n    ) internal view returns (IAlgebraPool pool) {\n        return verifyCallback(poolDeployer, PoolAddress.getPoolKey(tokenA, tokenB));\n    }\n\n    /// @notice Returns the address of a valid Algebra Pool\n    /// @param poolDeployer The contract address of the Algebra pool deployer\n    /// @param poolKey The identifying key of the ALgebra pool\n    /// @return pool The Algebra pool contract address\n    function verifyCallback(\n        address poolDeployer,\n        PoolAddress.PoolKey memory poolKey\n    ) internal view returns (IAlgebraPool pool) {\n        pool = IAlgebraPool(PoolAddress.computeAddress(poolDeployer, poolKey));\n        require(msg.sender == address(pool));\n    }\n}\n"
    },
    "contracts/libraries/ChainId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.0;\r\n\r\n/// @title Function for getting the current chain ID\r\nlibrary ChainId {\r\n    /// @dev Gets the current chain ID\r\n    /// @return chainId The current chain ID\r\n    function get() internal view returns (uint256 chainId) {\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/DataStorageLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.9.0;\n\nimport '@alkaswap/core/contracts/libraries/FullMath.sol';\nimport '@alkaswap/core/contracts/libraries/TickMath.sol';\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@alkaswap/core/contracts/interfaces/IDataStorageOperator.sol';\nimport '@alkaswap/core/contracts/libraries/LowGasSafeMath.sol';\n\nimport '../libraries/PoolAddress.sol';\n\n/// @title DataStorage library\n/// @notice Provides functions to integrate with pool dataStorage\nlibrary DataStorageLibrary {\n    /// @notice Fetches time-weighted average tick using Algebra dataStorage\n    /// @param pool Address of Algebra pool that we want to getTimepoints\n    /// @param period Number of seconds in the past to start calculating time-weighted average\n    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp\n    function consult(address pool, uint32 period) internal view returns (int24 timeWeightedAverageTick) {\n        require(period != 0, 'BP');\n\n        uint32[] memory secondAgos = new uint32[](2);\n        secondAgos[0] = period;\n        secondAgos[1] = 0;\n\n        IDataStorageOperator dsOperator = IDataStorageOperator(IAlgebraPool(pool).dataStorageOperator());\n        (int56[] memory tickCumulatives, ) = dsOperator.getTimepoints(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        timeWeightedAverageTick = int24(tickCumulativesDelta / int56(uint56(period)));\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(period)) != 0)) timeWeightedAverageTick--;\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n}\n"
    },
    "contracts/libraries/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport '@alkaswap/core/contracts/libraries/FullMath.sol';\nimport '@alkaswap/core/contracts/libraries/Constants.sol';\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, Constants.Q96);\n        unchecked {\n            return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n        }\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        unchecked {\n            return toUint128(FullMath.mulDiv(amount1, Constants.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n        }\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            return\n                FullMath.mulDiv(\n                    uint256(liquidity) << Constants.RESOLUTION,\n                    sqrtRatioBX96 - sqrtRatioAX96,\n                    sqrtRatioBX96\n                ) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        unchecked {\n            return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Constants.Q96);\n        }\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n        } else {\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        }\n    }\n}\n"
    },
    "contracts/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.6.0;\r\n\r\nimport './BytesLib.sol';\r\n\r\n/// @title Functions for manipulating path data for multihop swaps\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\nlibrary Path {\r\n    using BytesLib for bytes;\r\n\r\n    /// @dev The length of the bytes encoded address\r\n    uint256 private constant ADDR_SIZE = 20;\r\n\r\n    /// @dev The offset of a single token address\r\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE;\r\n    /// @dev The offset of an encoded pool key\r\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\r\n    /// @dev The minimum length of an encoding that contains 2 or more pools\r\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\r\n\r\n    /// @notice Returns true if the path contains two or more pools\r\n    /// @param path The encoded swap path\r\n    /// @return True if path contains two or more pools, otherwise false\r\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\r\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\r\n    }\r\n\r\n    /// @notice Returns the number of pools in the path\r\n    /// @param path The encoded swap path\r\n    /// @return The number of pools in the path\r\n    function numPools(bytes memory path) internal pure returns (uint256) {\r\n        // Ignore the first token address. From then on every token offset indicates a pool.\r\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Decodes the first pool in path\r\n    /// @param path The bytes encoded swap path\r\n    /// @return tokenA The first token of the given pool\r\n    /// @return tokenB The second token of the given pool\r\n    function decodeFirstPool(bytes memory path) internal pure returns (address tokenA, address tokenB) {\r\n        tokenA = path.toAddress(0);\r\n        tokenB = path.toAddress(NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Gets the segment corresponding to the first pool in the path\r\n    /// @param path The bytes encoded swap path\r\n    /// @return The segment containing all data necessary to target the first pool in the path\r\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\r\n        return path.slice(0, POP_OFFSET);\r\n    }\r\n\r\n    /// @notice Skips a token element from the buffer and returns the remainder\r\n    /// @param path The swap path\r\n    /// @return The remaining token elements in the path\r\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\r\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the poolDeployer and tokens\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xfb470dd52f1744c73f958b0d8756c3864c1ff3958598537bdd9f8733de444947;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(address tokenA, address tokenB) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB});\n    }\n\n    /// @notice Deterministically computes the pool address given the poolDeployer and PoolKey\n    /// @param poolDeployer The Algebra poolDeployer contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the Algebra pool\n    function computeAddress(address poolDeployer, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1, 'Invalid order of tokens');\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            poolDeployer,\n                            keccak256(abi.encode(key.token0, key.token1)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/libraries/PoolInteraction.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\n\nimport './PositionKey.sol';\n\n/// @title Implements commonly used interactions with Algebra pool\nlibrary PoolInteraction {\n    function _getPositionInPool(\n        IAlgebraPool pool,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    )\n        internal\n        view\n        returns (\n            uint256 liquidityAmount,\n            uint256 innerFeeGrowth0Token,\n            uint256 innerFeeGrowth1Token,\n            uint128 fees0,\n            uint128 fees1\n        )\n    {\n        bytes32 positionKey = PositionKey.compute(owner, tickLower, tickUpper);\n        return pool.positions(positionKey);\n    }\n\n    function _getSqrtPrice(IAlgebraPool pool) internal view returns (uint160 sqrtPriceX96) {\n        (sqrtPriceX96, , , , , , ) = pool.globalState();\n    }\n\n    function _burnPositionInPool(\n        IAlgebraPool pool,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        return pool.burn(tickLower, tickUpper, liquidity);\n    }\n}\n"
    },
    "contracts/libraries/PoolTicksCounter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\n\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\nlibrary PoolTicksCounter {\n    /// @dev This function counts the number of initialized ticks that would incur a gas cost between tickBefore and tickAfter.\n    /// When tickBefore and/or tickAfter themselves are initialized, the logic over whether we should count them depends on the\n    /// direction of the swap. If we are swapping upwards (tickAfter > tickBefore) we don't want to count tickBefore but we do\n    /// want to count tickAfter. The opposite is true if we are swapping downwards.\n    function countInitializedTicksCrossed(\n        IAlgebraPool self,\n        int24 tickBefore,\n        int24 tickAfter\n    ) internal view returns (uint32 initializedTicksCrossed) {\n        int16 wordPosLower;\n        int16 wordPosHigher;\n        uint8 bitPosLower;\n        uint8 bitPosHigher;\n        bool tickBeforeInitialized;\n        bool tickAfterInitialized;\n\n        {\n            // Get the key and offset in the tick bitmap of the active tick before and after the swap.\n            int16 wordPos = int16(tickBefore >> 8);\n            uint8 bitPos = uint8(int8(tickBefore % 256));\n\n            int16 wordPosAfter = int16(tickAfter >> 8);\n            uint8 bitPosAfter = uint8(int8(tickAfter % 256));\n\n            // In the case where tickAfter is initialized, we only want to count it if we are swapping downwards.\n            // If the initializable tick after the swap is initialized, our original tickAfter is a\n            // multiple of tick spacing, and we are swapping downwards we know that tickAfter is initialized\n            // and we shouldn't count it.\n            tickAfterInitialized =\n                ((self.tickTable(wordPosAfter) & (1 << bitPosAfter)) > 0) &&\n                ((tickAfter % self.tickSpacing()) == 0) &&\n                (tickBefore > tickAfter);\n\n            // In the case where tickBefore is initialized, we only want to count it if we are swapping upwards.\n            // Use the same logic as above to decide whether we should count tickBefore or not.\n            tickBeforeInitialized =\n                ((self.tickTable(wordPos) & (1 << bitPos)) > 0) &&\n                ((tickBefore % self.tickSpacing()) == 0) &&\n                (tickBefore < tickAfter);\n\n            if (wordPos < wordPosAfter || (wordPos == wordPosAfter && bitPos <= bitPosAfter)) {\n                wordPosLower = wordPos;\n                bitPosLower = bitPos;\n                wordPosHigher = wordPosAfter;\n                bitPosHigher = bitPosAfter;\n            } else {\n                wordPosLower = wordPosAfter;\n                bitPosLower = bitPosAfter;\n                wordPosHigher = wordPos;\n                bitPosHigher = bitPos;\n            }\n        }\n\n        // Count the number of initialized ticks crossed by iterating through the tick bitmap.\n        // Our first mask should include the lower tick and everything to its left.\n        uint256 mask = type(uint256).max << bitPosLower;\n        while (wordPosLower <= wordPosHigher) {\n            // If we're on the final tick bitmap page, ensure we only count up to our\n            // ending tick.\n            if (wordPosLower == wordPosHigher) {\n                mask = mask & (type(uint256).max >> (255 - bitPosHigher));\n            }\n\n            uint256 masked = self.tickTable(wordPosLower) & mask;\n            initializedTicksCrossed += countOneBits(masked);\n            wordPosLower++;\n            // Reset our mask so we consider all bits on the next iteration.\n            mask = type(uint256).max;\n        }\n\n        if (tickAfterInitialized) {\n            initializedTicksCrossed -= 1;\n        }\n\n        if (tickBeforeInitialized) {\n            initializedTicksCrossed -= 1;\n        }\n\n        return initializedTicksCrossed;\n    }\n\n    function countOneBits(uint256 x) private pure returns (uint16) {\n        uint16 bits = 0;\n        while (x != 0) {\n            bits++;\n            x &= (x - 1);\n        }\n        return bits;\n    }\n}\n"
    },
    "contracts/libraries/PositionKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\nlibrary PositionKey {\r\n    /// @dev Returns the key of the position in the core library\r\n    function compute(\r\n        address owner,\r\n        int24 bottomTick,\r\n        int24 topTick\r\n    ) internal pure returns (bytes32 key) {\r\n        assembly {\r\n            key := or(shl(24, or(shl(24, owner), and(bottomTick, 0xFFFFFF))), and(topTick, 0xFFFFFF))\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.6.0;\r\n\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\n\r\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\r\n/// https://github.com/Uniswap/v3-periphery\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\r\n        );\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers NativeToken to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferNative(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/WeightedDataStorageLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.9.0;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\n\nimport '@alkaswap/core/contracts/interfaces/IDataStorageOperator.sol';\n\n/// @title Weighted DataStorage library\n/// @notice Provides functions to integrate with dataStorage of the pool\nlibrary WeightedDataStorageLibrary {\n    /// @notice The result of observating a pool across a certain period\n    struct PeriodTimepoint {\n        int24 arithmeticMeanTick;\n        uint128 harmonicMeanLiquidity;\n    }\n\n    /// @notice Fetches a time-weighted timepoint for a given Algebra pool\n    /// @param pool Address of the pool that we want to getTimepoints\n    /// @param period Number of seconds in the past to start calculating the time-weighted timepoint\n    /// @return timepoint An timepoint that has been time-weighted from (block.timestamp - period) to block.timestamp\n    function consult(address pool, uint32 period) internal view returns (PeriodTimepoint memory timepoint) {\n        require(period != 0, 'BP');\n\n        uint192 periodX160 = uint192(period) * type(uint160).max;\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = period;\n        secondsAgos[1] = 0;\n\n        IDataStorageOperator dsOperator = IDataStorageOperator(IAlgebraPool(pool).dataStorageOperator());\n\n        (int56[] memory tickCumulatives, uint112[] memory secondsPerLiquidityCumulativeX128s) = dsOperator\n            .getTimepoints(secondsAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta = uint160(secondsPerLiquidityCumulativeX128s[1]) -\n            uint160(secondsPerLiquidityCumulativeX128s[0]);\n\n        timepoint.arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(period)));\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(period)) != 0))\n            timepoint.arithmeticMeanTick--;\n\n        // We are shifting the liquidity delta to ensure that the result doesn't overflow uint128\n        timepoint.harmonicMeanLiquidity = uint128(periodX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given some time-weighted timepoints, calculates the arithmetic mean tick, weighted by liquidity\n    /// @param timepoints A list of time-weighted timepoints\n    /// @return arithmeticMeanWeightedTick The arithmetic mean tick, weighted by the timepoints' time-weighted harmonic average liquidity\n    /// @dev In most scenarios, each entry of `timepoints` should share the same `period` and underlying `pool` tokens.\n    /// If `period` differs across timepoints, the result becomes difficult to interpret and is likely biased/manipulable.\n    /// If the underlying `pool` tokens differ across timepoints, extreme care must be taken to ensure that both prices and liquidity values are comparable.\n    /// Even if prices are commensurate (e.g. two different USD-stable assets against ETH), liquidity values may not be, as decimals can differ between tokens.\n    function getArithmeticMeanTickWeightedByLiquidity(\n        PeriodTimepoint[] memory timepoints\n    ) internal pure returns (int24 arithmeticMeanWeightedTick) {\n        // Accumulates the sum of all timepoints' products between each their own average tick and harmonic average liquidity\n        // Each product can be stored in a int160, so it would take approximately 2**96 timepoints to overflow this accumulator\n        int256 numerator;\n\n        // Accumulates the sum of the harmonic average liquidities from the given timepoints\n        // Each average liquidity can be stored in a uint128, so it will take approximately 2**128 timepoints to overflow this accumulator\n        uint256 denominator;\n\n        for (uint256 i; i < timepoints.length; i++) {\n            numerator += int256(uint256(timepoints[i].harmonicMeanLiquidity)) * timepoints[i].arithmeticMeanTick;\n            denominator += timepoints[i].harmonicMeanLiquidity;\n        }\n\n        arithmeticMeanWeightedTick = int24(numerator / int256(denominator));\n\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) arithmeticMeanWeightedTick--;\n    }\n}\n"
    },
    "contracts/SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/libraries/SafeCast.sol';\nimport '@alkaswap/core/contracts/libraries/TickMath.sol';\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\n\nimport './interfaces/ISwapRouter.sol';\nimport './base/PeripheryImmutableState.sol';\nimport './base/PeripheryValidation.sol';\nimport './base/PeripheryPaymentsWithFee.sol';\nimport './base/Multicall.sol';\nimport './base/SelfPermit.sol';\nimport './libraries/Path.sol';\nimport './libraries/PoolAddress.sol';\nimport './libraries/CallbackValidation.sol';\nimport './interfaces/external/IWNativeToken.sol';\n\n/// @title Algebra Swap Router\n/// @notice Router for stateless execution of swaps against Algebra\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ncontract SwapRouter is\n    ISwapRouter,\n    PeripheryImmutableState,\n    PeripheryValidation,\n    PeripheryPaymentsWithFee,\n    Multicall,\n    SelfPermit\n{\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap\n    /// can never actually be this value\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\n\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n\n    constructor(\n        address _factory,\n        address _WNativeToken,\n        address _poolDeployer\n    ) PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer) {}\n\n    /// @dev Returns the pool for the given token pair. The pool contract may or may not exist.\n    function getPool(address tokenA, address tokenB) private view returns (IAlgebraPool) {\n        return IAlgebraPool(PoolAddress.computeAddress(poolDeployer, PoolAddress.getPoolKey(tokenA, tokenB)));\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    /// @inheritdoc IAlgebraSwapCallback\n    function algebraSwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(poolDeployer, tokenIn, tokenOut);\n\n        (bool isExactInput, uint256 amountToPay) = amount0Delta > 0\n            ? (tokenIn < tokenOut, uint256(amount0Delta))\n            : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    /// @dev Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 limitSqrtPrice,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        if (recipient == address(0)) recipient = address(this); // allow swapping to the router address with address 0\n\n        (address tokenIn, address tokenOut) = data.path.decodeFirstPool();\n\n        bool zeroToOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) = getPool(tokenIn, tokenOut).swap(\n            recipient,\n            zeroToOne,\n            amountIn.toInt256(),\n            limitSqrtPrice == 0\n                ? (zeroToOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : limitSqrtPrice,\n            abi.encode(data)\n        );\n\n        return uint256(-(zeroToOne ? amount1 : amount0));\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\n        amountOut = exactInputInternal(\n            params.amountIn,\n            params.recipient,\n            params.limitSqrtPrice,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.tokenOut), payer: msg.sender})\n        );\n        require(amountOut >= params.amountOutMinimum, 'Too little received');\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactInput(\n        ExactInputParams memory params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies\n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), // only the first pool in the path is necessary\n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, 'Too little received');\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactInputSingleSupportingFeeOnTransferTokens(\n        ExactInputSingleParams calldata params\n    ) external override checkDeadline(params.deadline) returns (uint256 amountOut) {\n        SwapCallbackData memory data = SwapCallbackData({\n            path: abi.encodePacked(params.tokenIn, params.tokenOut),\n            payer: msg.sender\n        });\n        address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n        bool zeroToOne = params.tokenIn < params.tokenOut;\n\n        (int256 amount0, int256 amount1) = getPool(params.tokenIn, params.tokenOut).swapSupportingFeeOnInputTokens(\n            msg.sender,\n            recipient,\n            zeroToOne,\n            params.amountIn.toInt256(),\n            params.limitSqrtPrice == 0\n                ? (zeroToOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : params.limitSqrtPrice,\n            abi.encode(data)\n        );\n\n        amountOut = uint256(-(zeroToOne ? amount1 : amount0));\n\n        require(amountOut >= params.amountOutMinimum, 'Too little received');\n    }\n\n    /// @dev Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 limitSqrtPrice,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        if (recipient == address(0)) recipient = address(this); // allow swapping to the router address with address 0\n\n        (address tokenOut, address tokenIn) = data.path.decodeFirstPool();\n\n        bool zeroToOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) = getPool(tokenIn, tokenOut).swap(\n            recipient,\n            zeroToOne,\n            -amountOut.toInt256(),\n            limitSqrtPrice == 0\n                ? (zeroToOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : limitSqrtPrice,\n            abi.encode(data)\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroToOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it's technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (limitSqrtPrice == 0) require(amountOutReceived == amountOut);\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\n        // avoid an SLOAD by using the swap return data\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            params.limitSqrtPrice,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.tokenIn), payer: msg.sender})\n        );\n\n        require(amountIn <= params.amountInMaximum, 'Too much requested');\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED; // has to be reset even though we don't use it in the single hop case\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\n        // it's okay that the payer is fixed to msg.sender here, as they're only paying for the \"final\" exact output\n        // swap, which happens first, and subsequent swaps are paid for within nested callback frames\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n        require(amountIn <= params.amountInMaximum, 'Too much requested');\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n    }\n}\n"
    },
    "contracts/test/LiquidityAmountsTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\n\r\nimport '../libraries/LiquidityAmounts.sol';\r\n\r\ncontract LiquidityAmountsTest {\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) external pure returns (uint128 liquidity) {\r\n        return LiquidityAmounts.getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\r\n    }\r\n\r\n    function getGasCostOfGetLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) external view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        LiquidityAmounts.getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\r\n        return gasBefore - gasleft();\r\n    }\r\n\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) external pure returns (uint128 liquidity) {\r\n        return LiquidityAmounts.getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\r\n    }\r\n\r\n    function getGasCostOfGetLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) external view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        LiquidityAmounts.getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\r\n        return gasBefore - gasleft();\r\n    }\r\n\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) external pure returns (uint128 liquidity) {\r\n        return LiquidityAmounts.getLiquidityForAmounts(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1);\r\n    }\r\n\r\n    function getGasCostOfGetLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) external view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        LiquidityAmounts.getLiquidityForAmounts(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1);\r\n        return gasBefore - gasleft();\r\n    }\r\n\r\n    function getAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) external pure returns (uint256 amount0) {\r\n        return LiquidityAmounts.getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n    }\r\n\r\n    function getGasCostOfGetAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) external view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        LiquidityAmounts.getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        return gasBefore - gasleft();\r\n    }\r\n\r\n    function getAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) external pure returns (uint256 amount1) {\r\n        return LiquidityAmounts.getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n    }\r\n\r\n    function getGasCostOfGetAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) external view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        LiquidityAmounts.getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        return gasBefore - gasleft();\r\n    }\r\n\r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) external pure returns (uint256 amount0, uint256 amount1) {\r\n        return LiquidityAmounts.getAmountsForLiquidity(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n    }\r\n\r\n    function getGasCostOfGetAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) external view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        LiquidityAmounts.getAmountsForLiquidity(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        return gasBefore - gasleft();\r\n    }\r\n}\r\n"
    },
    "contracts/test/MockTimeSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\npragma abicoder v2;\r\n\r\nimport '../SwapRouter.sol';\r\n\r\ncontract MockTimeSwapRouter is SwapRouter {\r\n    uint256 time;\r\n\r\n    constructor(\r\n        address _factory,\r\n        address _WNativeToken,\r\n        address _poolDeployer\r\n    ) SwapRouter(_factory, _WNativeToken, _poolDeployer) {}\r\n\r\n    function _blockTimestamp() internal view override returns (uint256) {\r\n        return time;\r\n    }\r\n\r\n    function setTime(uint256 _time) external {\r\n        time = _time;\r\n    }\r\n}\r\n"
    },
    "contracts/test/NonfungiblePositionManagerPositionsGasTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\n\r\nimport '../interfaces/INonfungiblePositionManager.sol';\r\n\r\ncontract NonfungiblePositionManagerPositionsGasTest {\r\n    INonfungiblePositionManager immutable nonfungiblePositionManager;\r\n\r\n    constructor(INonfungiblePositionManager _nonfungiblePositionManager) {\r\n        nonfungiblePositionManager = _nonfungiblePositionManager;\r\n    }\r\n\r\n    function getGasCostOfPositions(uint256 tokenId) external view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        nonfungiblePositionManager.positions(tokenId);\r\n        return gasBefore - gasleft();\r\n    }\r\n}\r\n"
    },
    "contracts/test/OracleTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\n\r\nimport '../libraries/DataStorageLibrary.sol';\r\n\r\ncontract DataStorageTest {\r\n    function consult(address pool, uint32 period) public view returns (int24 timeWeightedAverageTick) {\r\n        timeWeightedAverageTick = DataStorageLibrary.consult(pool, period);\r\n    }\r\n\r\n    function getQuoteAtTick(\r\n        int24 tick,\r\n        uint128 baseAmount,\r\n        address baseToken,\r\n        address quoteToken\r\n    ) public pure returns (uint256 quoteAmount) {\r\n        quoteAmount = DataStorageLibrary.getQuoteAtTick(tick, baseAmount, baseToken, quoteToken);\r\n    }\r\n\r\n    // For gas snapshot test\r\n    function getGasCostOfConsult(address pool, uint32 period) public view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        DataStorageLibrary.consult(pool, period);\r\n        return gasBefore - gasleft();\r\n    }\r\n\r\n    function getGasCostOfGetQuoteAtTick(\r\n        int24 tick,\r\n        uint128 baseAmount,\r\n        address baseToken,\r\n        address quoteToken\r\n    ) public view returns (uint256) {\r\n        uint256 gasBefore = gasleft();\r\n        DataStorageLibrary.getQuoteAtTick(tick, baseAmount, baseToken, quoteToken);\r\n        return gasBefore - gasleft();\r\n    }\r\n}\r\n"
    },
    "contracts/test/PeripheryImmutableStateTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\nimport '../base/PeripheryImmutableState.sol';\r\n\r\ncontract PeripheryImmutableStateTest is PeripheryImmutableState {\r\n    constructor(\r\n        address _factory,\r\n        address _WNativeToken,\r\n        address _poolDeployer\r\n    ) PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer) {}\r\n}\r\n"
    },
    "contracts/test/PoolAddressTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\n\r\nimport '../libraries/PoolAddress.sol';\r\n\r\ncontract PoolAddressTest {\r\n    function POOL_INIT_CODE_HASH() external pure returns (bytes32) {\r\n        return PoolAddress.POOL_INIT_CODE_HASH;\r\n    }\r\n\r\n    function computeAddress(\r\n        address factory,\r\n        address token0,\r\n        address token1,\r\n        uint24 fee\r\n    ) external pure returns (address) {\r\n        fee;\r\n        return PoolAddress.computeAddress(factory, PoolAddress.PoolKey({token0: token0, token1: token1}));\r\n    }\r\n\r\n    function getGasCostOfComputeAddress(\r\n        address factory,\r\n        address token0,\r\n        address token1,\r\n        uint24 fee\r\n    ) external view returns (uint256) {\r\n        fee;\r\n        uint256 gasBefore = gasleft();\r\n        PoolAddress.computeAddress(factory, PoolAddress.PoolKey({token0: token0, token1: token1}));\r\n        return gasBefore - gasleft();\r\n    }\r\n}\r\n"
    },
    "contracts/test/PoolTicksCounterTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\n\npragma solidity >=0.8.17;\n\nimport '../libraries/PoolTicksCounter.sol';\n\ncontract PoolTicksCounterTest {\n    using PoolTicksCounter for IAlgebraPool;\n\n    function countInitializedTicksCrossed(\n        IAlgebraPool pool,\n        int24 tickBefore,\n        int24 tickAfter\n    ) external view returns (uint32 initializedTicksCrossed) {\n        return pool.countInitializedTicksCrossed(tickBefore, tickAfter);\n    }\n}\n"
    },
    "contracts/test/TestAlgebraCallee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.17;\n\nimport '@alkaswap/core/contracts/interfaces/callback/IAlgebraSwapCallback.sol';\nimport '@alkaswap/core/contracts/libraries/SafeCast.sol';\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract TestAlgebraCallee is IAlgebraSwapCallback {\n    using SafeCast for uint256;\n\n    function swapExact0For1(address pool, uint256 amount0In, address recipient, uint160 limitSqrtPrice) external {\n        IAlgebraPool(pool).swap(recipient, true, amount0In.toInt256(), limitSqrtPrice, abi.encode(msg.sender));\n    }\n\n    function swap0ForExact1(address pool, uint256 amount1Out, address recipient, uint160 limitSqrtPrice) external {\n        IAlgebraPool(pool).swap(recipient, true, -amount1Out.toInt256(), limitSqrtPrice, abi.encode(msg.sender));\n    }\n\n    function swapExact1For0(address pool, uint256 amount1In, address recipient, uint160 limitSqrtPrice) external {\n        IAlgebraPool(pool).swap(recipient, false, amount1In.toInt256(), limitSqrtPrice, abi.encode(msg.sender));\n    }\n\n    function swap1ForExact0(address pool, uint256 amount0Out, address recipient, uint160 limitSqrtPrice) external {\n        IAlgebraPool(pool).swap(recipient, false, -amount0Out.toInt256(), limitSqrtPrice, abi.encode(msg.sender));\n    }\n\n    function algebraSwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {\n        address sender = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            IERC20(IAlgebraPool(msg.sender).token0()).transferFrom(sender, msg.sender, uint256(amount0Delta));\n        } else {\n            assert(amount1Delta > 0);\n            IERC20(IAlgebraPool(msg.sender).token1()).transferFrom(sender, msg.sender, uint256(amount1Delta));\n        }\n    }\n}\n"
    },
    "contracts/test/TestCallbackValidation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\n\r\nimport '../libraries/CallbackValidation.sol';\r\n\r\ncontract TestCallbackValidation {\r\n    function verifyCallback(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (IAlgebraPool pool) {\r\n        return CallbackValidation.verifyCallback(factory, tokenA, tokenB);\r\n    }\r\n}\r\n"
    },
    "contracts/test/TestMulticall.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\npragma abicoder v2;\r\n\r\nimport '../base/Multicall.sol';\r\n\r\ncontract TestMulticall is Multicall {\r\n    function functionThatRevertsWithError(string memory error) external pure {\r\n        revert(error);\r\n    }\r\n\r\n    struct Tuple {\r\n        uint256 a;\r\n        uint256 b;\r\n    }\r\n\r\n    function functionThatReturnsTuple(uint256 a, uint256 b) external pure returns (Tuple memory tuple) {\r\n        tuple = Tuple({b: a, a: b});\r\n    }\r\n\r\n    uint256 public paid;\r\n\r\n    function pays() external payable {\r\n        paid += msg.value;\r\n    }\r\n\r\n    function returnSender() external view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n"
    },
    "contracts/test/TickLensTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/interfaces/IAlgebraPool.sol';\nimport '../lens/TickLens.sol';\n\n/// @title Tick Lens contract\ncontract TickLensTest is TickLens {\n    function getGasCostOfGetPopulatedTicksInWord(address pool, int16 tickTableIndex) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        getPopulatedTicksInWord(pool, tickTableIndex);\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/test/WeightedOracleTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\npragma abicoder v2;\r\n\r\nimport '../libraries/WeightedDataStorageLibrary.sol';\r\n\r\ncontract WeightedDataStorageTest {\r\n    function consult(address pool, uint32 period)\r\n        public\r\n        view\r\n        returns (WeightedDataStorageLibrary.PeriodTimepoint memory timepoint)\r\n    {\r\n        timepoint = WeightedDataStorageLibrary.consult(pool, period);\r\n    }\r\n\r\n    function getArithmeticMeanTickWeightedByLiquidity(WeightedDataStorageLibrary.PeriodTimepoint[] memory timepoints)\r\n        public\r\n        pure\r\n        returns (int24 arithmeticMeanWeightedTick)\r\n    {\r\n        arithmeticMeanWeightedTick = WeightedDataStorageLibrary.getArithmeticMeanTickWeightedByLiquidity(timepoints);\r\n    }\r\n}\r\n"
    },
    "contracts/V3Migrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@alkaswap/core/contracts/libraries/LowGasSafeMath.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport './interfaces/INonfungiblePositionManager.sol';\n\nimport './libraries/TransferHelper.sol';\n\nimport './interfaces/IV3Migrator.sol';\nimport './base/PeripheryImmutableState.sol';\nimport './base/Multicall.sol';\nimport './base/SelfPermit.sol';\nimport './interfaces/external/IWNativeToken.sol';\nimport './base/PoolInitializer.sol';\n\n/// @title Algebra Migrator\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ncontract V3Migrator is IV3Migrator, PeripheryImmutableState, PoolInitializer, Multicall, SelfPermit {\n    using LowGasSafeMath for uint256;\n\n    address public immutable nonfungiblePositionManager;\n\n    constructor(\n        address _factory,\n        address _WNativeToken,\n        address _nonfungiblePositionManager,\n        address _poolDeployer\n    ) PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer) {\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n    }\n\n    receive() external payable {\n        require(msg.sender == WNativeToken, 'Not WNativeToken');\n    }\n\n    function migrate(MigrateParams calldata params) external override {\n        require(params.percentageToMigrate > 0, 'Percentage too small');\n        require(params.percentageToMigrate <= 100, 'Percentage too large');\n\n        // burn v2 liquidity to this address\n        IUniswapV2Pair(params.pair).transferFrom(msg.sender, params.pair, params.liquidityToMigrate);\n        (uint256 amount0V2, uint256 amount1V2) = IUniswapV2Pair(params.pair).burn(address(this));\n\n        // calculate the amounts to migrate to v3\n        uint256 amount0V2ToMigrate = (amount0V2 * params.percentageToMigrate) / 100;\n        uint256 amount1V2ToMigrate = (amount1V2 * params.percentageToMigrate) / 100;\n\n        // approve the position manager up to the maximum token amounts\n        TransferHelper.safeApprove(params.token0, nonfungiblePositionManager, amount0V2ToMigrate);\n        TransferHelper.safeApprove(params.token1, nonfungiblePositionManager, amount1V2ToMigrate);\n\n        // mint v3 position\n        (, , uint256 amount0V3, uint256 amount1V3) = INonfungiblePositionManager(nonfungiblePositionManager).mint(\n            INonfungiblePositionManager.MintParams({\n                token0: params.token0,\n                token1: params.token1,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: amount0V2ToMigrate,\n                amount1Desired: amount1V2ToMigrate,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: params.recipient,\n                deadline: params.deadline\n            })\n        );\n\n        // if necessary, clear allowance and refund dust\n        if (amount0V3 < amount0V2) {\n            if (amount0V3 < amount0V2ToMigrate) {\n                TransferHelper.safeApprove(params.token0, nonfungiblePositionManager, 0);\n            }\n\n            uint256 refund0 = amount0V2 - amount0V3;\n            if (params.refundAsNative && params.token0 == WNativeToken) {\n                IWNativeToken(WNativeToken).withdraw(refund0);\n                TransferHelper.safeTransferNative(msg.sender, refund0);\n            } else {\n                TransferHelper.safeTransfer(params.token0, msg.sender, refund0);\n            }\n        }\n\n        if (amount1V3 < amount1V2) {\n            if (amount1V3 < amount1V2ToMigrate) {\n                TransferHelper.safeApprove(params.token1, nonfungiblePositionManager, 0);\n            }\n\n            uint256 refund1 = amount1V2 - amount1V3;\n            if (params.refundAsNative && params.token1 == WNativeToken) {\n                IWNativeToken(WNativeToken).withdraw(refund1);\n                TransferHelper.safeTransferNative(msg.sender, refund1);\n            } else {\n                TransferHelper.safeTransfer(params.token1, msg.sender, refund1);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}